{"107956748": {"text": "This pull request fixes a bug in CYGWIN.\n\nThe processes created with `Process#exec` not receive environment variables specified in the parameter `env`. Related methods (`Process#spawn`, `Kernel#exec`, `Kernel#spawn`, ... ) are also affected.\n\nThis sentence:\n`ruby -e 'Process.exec( {\"MYVAR\" => \"42\"}, \"echo MYVAR: $MYVAR\" )'`\nshould prints:\n`MYVAR: 42`\nbut it prints:\n`MYVAR:`\n", "labels": [], "number": 1029, "updated_at": "2015-09-24 06:20:47", "user": 1894063, "closed_at": null, "id": 107956748, "title": "env for Process#exec in CYGWIN", "url": "https://api.github.com/repos/ruby/ruby/issues/1029", "created_at": "2015-09-23 16:23:59", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "109223437": {"text": "Of course the tests in place have not been modified. So go red green refactor and think about it.\nWhy did I change just one number? The results that I have been getting from `DateTime.jd`(any good `ajd` with some time in it) is off by 12 or half a day short. Maybe I don't know what I'm doing but it's in that method somewhere and my install of the trunk gives me better results. Make check did fail there though but then so did so many other tests that by that time I didn't care because my old piece of junk laptop has been spitting up chunks and I end up having to reload the system anyway. So I installed Ruby in root not a user. It defaults to `/usr/local/bin` and so does not mess up my system install of 1.9.1 from Debian of old behind the times wheezy kali dragon that never did any metasploitation for any reason because it's selfish and just wants to hoard the treasure. ;-D\n", "labels": [], "number": 1039, "updated_at": "2015-10-05 01:03:38", "user": 887598, "closed_at": null, "id": 109223437, "title": "Update date_core.c", "url": "https://api.github.com/repos/ruby/ruby/issues/1039", "created_at": "2015-10-01 03:33:03", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/145406834", "text": ">  The results that I have been getting from `DateTime.jd`(any good `ajd` with some time in it) is off by 12 or half a day short.\n\nPlease elaborate the difference and your expectation, (with code preferably).\n", "created_at": "2015-10-05 01:03:38", "user": 16700, "id": 145406834}], "assignees": [], "state": "open", "is-pull-request": true}, "224044046": {"text": "\u2026internally\r\n\r\nSome Complex methods call Numeric#real? at f_real_p() using rb_funcall().\r\nThis patch will provide optimization in f_real_p() when Integer/Float is given as internal objects.\r\n\r\n* Before\r\n```\r\nCalculating -------------------------------------\r\n           Complex#+      5.226M (\u00b1 3.9%) i/s -     26.145M in   5.011147s\r\n           Complex#-      5.274M (\u00b1 4.4%) i/s -     26.321M in   5.001267s\r\n           Complex#*      3.217M (\u00b1 4.7%) i/s -     16.092M in   5.013429s\r\n```\r\n\r\n* After\r\n```\r\nCalculating -------------------------------------\r\n           Complex#+      6.925M (\u00b1 5.4%) i/s -     34.559M in   5.006583s\r\n           Complex#-      7.124M (\u00b1 4.8%) i/s -     35.652M in   5.017364s\r\n           Complex#*      3.880M (\u00b1 4.1%) i/s -     19.363M in   5.000170s\r\n```\r\n\r\n* Test code\r\n```\r\nrequire 'benchmark/ips'\r\n\r\nBenchmark.ips do |x|\r\n  c1 = Complex(2, 3)\r\n  c2 = Complex(2, 3)\r\n\r\n  x.report \"Complex#+\" do |t|\r\n    t.times { c1 + c2 }\r\n  end\r\n\r\n  x.report \"Complex#-\" do |t|\r\n    t.times { c1 - c2 }\r\n  end\r\n\r\n  x.report \"Complex#*\" do |t|\r\n    t.times { c1 * c2 }\r\n  end\r\n\r\nend\r\n```\r\n", "labels": [], "number": 1598, "updated_at": "2018-02-23 03:07:35", "user": 199156, "closed_at": null, "id": 224044046, "title": "Improve performance of some Complex methods where call Numeric#real? \u2026", "url": "https://api.github.com/repos/ruby/ruby/issues/1598", "created_at": "2017-04-25 07:19:27", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "274679826": {"text": "Rubocop prefers `empty?` over `length == 0` and `size == 0`, which is great for String, Array, Hash, etc. It would be nice if more classes implemented `#empty?` for consistency.\r\n\r\nSee related discussion at https://github.com/bbatsov/rubocop/issues/2841\r\n\r\nhttps://bugs.ruby-lang.org/issues/14136", "labels": [], "number": 1759, "updated_at": "2018-02-23 03:07:41", "user": 14068, "closed_at": null, "id": 274679826, "title": "Add #empty? to Tempfile, StringIO, File::Stat", "url": "https://api.github.com/repos/ruby/ruby/issues/1759", "created_at": "2017-11-16 22:03:28", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/345080564", "text": "I couldn't find where to add tests for `File::Stat#empty?`, but that one just an alias. Maybe it isn't valuable enough to test it. \u00af\\\\\\_(\u30c4)_/\u00af", "created_at": "2017-11-16 22:16:23", "user": 14068, "id": 345080564}], "assignees": [], "state": "open", "is-pull-request": true}, "184738323": {"text": "How about adding UnboundMethod to class suggestion?\n\n``` rb\nmodule A\n  def foo\n  end\nend\np A.instance_method(:foo) #=> #<UnboundMethod: A#foo>\ndefine_method(:bar, A.instance_method(:foo))\n```\n", "labels": [], "number": 1465, "updated_at": "2018-02-23 03:07:22", "user": 935310, "closed_at": null, "id": 184738323, "title": "Module#define_method: Add UnboundMethod to expected classes", "url": "https://api.github.com/repos/ruby/ruby/issues/1465", "created_at": "2016-10-24 02:53:09", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "157354013": {"text": "This fix should make opening a TCP connection in Net::HTTP#connect more efficient since we won't have to spin up a Timeout.timeout thread each time we open a connection. Also, we avoid the race conditions inherent in the use of Timeout.timeout, as detailed at http://blog.headius.com/2008/02/ruby-threadraise-threadkill-timeoutrb.html\n", "labels": [], "number": 1370, "updated_at": "2018-02-23 03:07:13", "user": 1011417, "closed_at": null, "id": 157354013, "title": "Use connect_nonblock to open TCP connections in Net::HTTP#connect", "url": "https://api.github.com/repos/ruby/ruby/issues/1370", "created_at": "2016-05-28 19:40:39", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/223731485", "text": "@nurse @tenderlove I did the same thing as PR https://github.com/ruby/ruby/pull/899 but for connecting the TCP socket, does this PR look ok to you guys? Works fine as far as I can tell\n\n(oh and fyi I opened an issue on redmine in case this needs discussion: https://bugs.ruby-lang.org/issues/12435)\n", "created_at": "2016-06-04 02:36:49", "user": 1011417, "id": 223731485}], "assignees": [], "state": "open", "is-pull-request": true}, "293518879": {"text": "Instead of wrapping TCPSocket.open with a Timeout.timeout, we rely on the kernel's socket connect timeout, avoiding a temporary thread just for the timeout.", "labels": [], "number": 1806, "updated_at": "2018-02-23 03:07:44", "user": 180046, "closed_at": null, "id": 293518879, "title": "net/http: use connect_timeout in Socket.tcp", "url": "https://api.github.com/repos/ruby/ruby/issues/1806", "created_at": "2018-02-01 12:51:36", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/362256821", "text": "https://bugs.ruby-lang.org/issues/14430", "created_at": "2018-02-01 12:52:11", "user": 180046, "id": 362256821}], "assignees": [], "state": "open", "is-pull-request": true}, "296134177": {"text": "Ruby 2.4 fails to build with OpenSSL 1.1.0 on my machine, without any compat layer/API enabled in OpenSSL (`--api=1.0.0` passed to OpenSSL's _configure_, no `OPENSSL_API_COMPAT` defined when building Ruby's OpenSSL extension).\r\n\r\nThis PR attempts to fix this by:\r\n* adding a few missing headers\r\n* checking for some additional functions\r\n* refraining from calling some functions that were completely removed in OpenSSL 1.1.0\r\n\r\nAt least on my machine, with these changes Ruby 2.4 builds fine against OpenSSL 1.1.0g, and seems to run fine.\r\n\r\nPlease review! :)", "labels": [], "number": 1815, "updated_at": "2018-02-10 23:07:56", "user": 2384790, "closed_at": null, "id": 296134177, "title": "Improve compatibility with OpenSSL 1.1.0", "url": "https://api.github.com/repos/ruby/ruby/issues/1815", "created_at": "2018-02-10 21:10:22", "comments": [], "assignees": [1033740, 1033740], "state": "open", "is-pull-request": true}, "134182435": {"text": "https://bugs.ruby-lang.org/issues/11286\n\nI've refrained from adding an entry to the Changelog since this is largely @nobu's work. Opening a PR here for increased visibility.\n", "labels": [], "number": 1253, "updated_at": "2018-02-23 03:07:07", "user": 11608949, "closed_at": null, "id": 134182435, "title": "enum.c: add #grep-like behavior to #any? and friends.", "url": "https://api.github.com/repos/ruby/ruby/issues/1253", "created_at": "2016-02-17 05:23:36", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/185038946", "text": "Whoops! RubySpec doesn't like this change, but I'd be happy to fix that with some assurance that it'd be worthwhile.\n", "created_at": "2016-02-17 05:49:24", "user": 11608949, "id": 185038946}], "assignees": [], "state": "open", "is-pull-request": true}, "216819749": {"text": "`Resolv::DNS::Name.create(str)` does not make any validation.\r\nAnd it returns false positive results for queries like\r\n\r\n`Resolv::DNS.new.getresources('.gmail....com', Resolv::DNS::Resource::IN::MX)`\r\n\r\nI added basic RFC validations in `Resolv::DNS::Label.split` to get ArgumentError with messages similar to host and dig commands.", "labels": [], "number": 1551, "updated_at": "2018-02-23 03:07:32", "user": 5870040, "closed_at": null, "id": 216819749, "title": "Make Resolv::DNS::Name validation similar to host and dig commands.", "url": "https://api.github.com/repos/ruby/ruby/issues/1551", "created_at": "2017-03-24 15:26:43", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "279868971": {"text": "To address this issue [#14151](https://bugs.ruby-lang.org/issues/14151)", "labels": [], "number": 1769, "updated_at": "2018-03-18 13:28:26", "user": 17675583, "closed_at": null, "id": 279868971, "title": "Make Matrix#[]= public method", "url": "https://api.github.com/repos/ruby/ruby/issues/1769", "created_at": "2017-12-06 19:02:04", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/350393481", "text": "@marcandre Ping", "created_at": "2017-12-08 22:59:56", "user": 17675583, "id": 350393481}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/350771408", "text": "As is, this PR is not acceptable. Here's the todo list for this PR to be make Matrix mutable in an acceptable way:\r\n\r\n1) deal with indices as ranges\r\n\r\n`m[1..2, 1..2] = 42` #  => Sets the 4 entries to 42. Must accept small negative ranges too\r\n`m[1..2, 1..2] = matrix` # => Sets the 4 entries from the entries of the given 2x2 matrix\r\nSame with  `m[1, 1..2] = 42 / vector / matrix` and `m[1..2, 1]=...`\r\n\r\nNote: it's acceptable to use `is_a?(Range)` to recognize ranges. For ints, there's already  `coerce_to_int`.\r\n\r\n2) Define `map!`, which should accept a parameter `:diagonal`, etc.\r\n\r\n3) Handle `freeze` correctly.\r\n`m.freeze.[...]= ...` must raise, same with `map!`\r\n\r\n4) `dup` probably needs to be defined\r\n\r\n5) specs for all of these, ideally in `ruby/spec`\r\n\r\nLet me know if you're up to update your PR or not...", "created_at": "2017-12-11 16:11:13", "user": 33770, "id": 350771408}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/350853263", "text": "@marcandre Thanks for your update and feedback. At the moment I'm unable to update my PR to meet all of the things you mentioned.(work and school related) But I'll be able to do it in the near future unless there is some specific schedule or anybody else wants to do it.", "created_at": "2017-12-11 20:48:01", "user": 17675583, "id": 350853263}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/353869716", "text": "@marcandre I took care of the first point you mentioned. I'd be grateful if you or somebody could provide some feedback about my code so I could fix or simplify it. Shortly, I'll create commits with regard to the rest of points.", "created_at": "2017-12-25 13:29:17", "user": 17675583, "id": 353869716}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/353897045", "text": "You could replace ``is_subrange?(row_range, i)`` with an optimized ``in_row_range?(i)`` that avoids creating a temporary Range, the same could be done for ``column_range``.\r\nThe current method ``is_subrange?`` looks like a good candidate for a Range method.\r\nMaybe renamed to ``subrange?`` or ``between?`` if moved to Range, to match ``cover?`` and ``include?``.\r\n\r\nThe calls to ``row_range.cover?(i)`` and ``column_range.cover?(j)`` could be replaced by ``i.between?(-row, row-1)`` or just ``-row <= i and i < row``, as they are used only once each.\r\nI don't see the need for ``row_range`` and ``column_range`` as temporary ``-x...x`` range creators.\r\n\r\n", "created_at": "2017-12-26 00:11:19", "user": 11094484, "id": 353897045}, {"reactions": {"+1": [11094484]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/353974738", "text": "@Maumagnaguagno Thanks a lot for your feedback. I made changes according to it.", "created_at": "2017-12-26 14:31:18", "user": 17675583, "id": 353974738}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/353978928", "text": "Hey @greggzst, I noticed you fixed the last commit with a ``range.to_a`` to fix exclude end Ranges.\r\nThis works, but I believe it is slow, as it creates an array with every element in range.\r\nInstead you could just use ``range.max`` to pick the last element in range.", "created_at": "2017-12-26 15:15:26", "user": 11094484, "id": 353978928}, {"reactions": {"+1": [11094484]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354000200", "text": "@Maumagnaguagno Thanks! Fixed that!", "created_at": "2017-12-26 18:46:58", "user": 17675583, "id": 354000200}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354174791", "text": "Lots of good work in there.\r\n\r\nI notice right away a few things:\r\n- there are some `range.to_a` left. You shouldn't ever have to call `to_a`.\r\n- Use `i = coerce_to_int(i)` (i.e. use the result). If you were writing ruby-spec style instead of tests, this would have been more easier to catch.\r\n- `IndexError` is the more precise exception class to raise for bad indices\r\n- It's great you have tests; could you split them a bit? It's hard to follow what's tested (and what might be missing)", "created_at": "2017-12-27 20:41:43", "user": 33770, "id": 354174791}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354279787", "text": "@marcandre Thanks a lot I addressed every point but `range.to_a`. Is it acceptable to use `each_with_index` on range to get the appropriate index from it?\r\n\r\n```\r\nv.each_with_index do |e, row, col|\r\n  r = nil\r\n  i.each_with_index do |i , index|\r\n    if index == row\r\n      r = i\r\n      break\r\n    end\r\n  end\r\n  c = nil\r\n  j.each_with_index do |j , index|\r\n    if index == col\r\n      c = j\r\n      break\r\n    end\r\n  end\r\n  @rows[r][c] = e\r\nend\r\n```\r\nI can't come up with any other idea and couldn't find any method in `Range` that returns element at specific index.", "created_at": "2017-12-28 12:17:38", "user": 17675583, "id": 354279787}, {"reactions": {"+1": [17675583]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354282157", "text": "Maybe ``r = i.first + row``?", "created_at": "2017-12-28 12:37:42", "user": 11094484, "id": 354282157}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354450554", "text": "I definied `map!` and `freeze` any feedback about these two?", "created_at": "2017-12-29 14:10:07", "user": 17675583, "id": 354450554}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354484732", "text": "Implemented all things for `Vector` as well but there is no `IndexError` defined. Should I define it?", "created_at": "2017-12-29 18:44:56", "user": 17675583, "id": 354484732}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354535623", "text": "All done, anything else I should do? What should I do about this `IndexError` in `Vector` class?", "created_at": "2017-12-30 09:09:27", "user": 17675583, "id": 354535623}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354680305", "text": "The message associated with `FrozenError` is wrong and it says `can't modify frozen Array` is there any way to override it? ", "created_at": "2018-01-01 22:00:24", "user": 17675583, "id": 354680305}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354834244", "text": "I think that the way `clone` method was implemented both in `Matrix` and `Vector` is actually the way `dup` should be implemented because both of them disregard state of the object. So I renamed them to `dup` and defined proper `map` for `Matrix` which accepts parameters through `which` as other methods.", "created_at": "2018-01-02 18:06:50", "user": 17675583, "id": 354834244}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/357272451", "text": "@marcandre Any feedback on `map` implementation? What about the message produced by `FrozenError`? It's currently wrong as I mentioned it earlier.", "created_at": "2018-01-12 15:42:35", "user": 17675583, "id": 357272451}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/358139801", "text": "@marcandre ping", "created_at": "2018-01-16 23:15:21", "user": 17675583, "id": 358139801}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/358839225", "text": "Sorry, I'm travelling right now.\r\n\r\n`map!` looks pretty good at first sight. It's probably worth it to use `@rows[row_index][col_index] = ...` instead of `self[row_index, col_index] = ...`, though. Less method calls, range checking, etc.\r\n\r\nAlso, should raise an error on empty matrices (like `[].map!{}` does). Good opportunity to fix the message?", "created_at": "2018-01-19 01:33:45", "user": 33770, "id": 358839225}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/358899788", "text": "I'm using `@rows` right now. `[].map!{}` doesn't actually raise any error(checked it in IRB and it returns `[]`) so I didn't change it for matrices. When it comes to `FrozenError` I still don't know how to fix the message but I think the main issue is that it is invoked when `@rows[row][col] = ...` is called and that's the reason why the message says `can't modify frozen Array` instead of `can't modify frozen Matrix`. Any suggestions on that? Also I fixed conflict on this branch by creating a new one from recent `trunk` and `cherry-picking` my commits.", "created_at": "2018-01-19 08:33:34", "user": 17675583, "id": 358899788}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/359115024", "text": "Sorry, I meant `[].freeze.map!{}`, which does raise.", "created_at": "2018-01-19 23:07:49", "user": 33770, "id": 359115024}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/359166582", "text": "Okay now I see but I can't get my head around this I mean I don't know how to fix it for know because with empty matrix it never gets to the inner `each_with_index` where `yield` gets called and that's why the `FrozenError` isn't raised. I'll try to figure it out later on but if you've got any tips on that let me know. I mean I could just raise the error in `map!` when matrix is empty and frozen but I don't think it's a good idea.\r\n\r\nI think we don't have to care about `FrozenError` message anymore I checked `Set` and its `FrozenError` messages say `can't modify frozen Hash` so I guess its fine.", "created_at": "2018-01-20 12:02:44", "user": 17675583, "id": 359166582}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/359206999", "text": "Indeed. You'll need to add an explicit `raise .... if frozen?`", "created_at": "2018-01-20 22:26:28", "user": 33770, "id": 359206999}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/359208133", "text": "Done. Anything else I should do?", "created_at": "2018-01-20 22:47:10", "user": 17675583, "id": 359208133}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/360544455", "text": "I introduced some refactoring and optimizations I came up with. I benchmarked most of them as well using this code:\r\n```\r\nrequire 'benchmark/ips'\r\nrequire 'matrix'\r\n\r\na = Array.new(1000){ Array.new(1000){ rand(25..1250) } }\r\ni = 50..980\r\nj = 20..700\r\n\r\nBenchmark.ips do |x|\r\n  x.report('set_row_and_col - double each') do\r\n    i.each do |i|\r\n      j.each do |j|\r\n        a[i][j] = 5\r\n      end\r\n    end\r\n  end\r\n\r\n  x.report('set_row_and_col - one each and range - Array.new') do\r\n    set_value = Array.new(j.size, 5)\r\n    i.each do |i|\r\n      a[i][j] = set_value\r\n    end\r\n  end\r\n\r\n  x.report('set_row_and_col - one each and range - map!') do\r\n    i.each do |i|\r\n      a[i][j].map!{ 5 }\r\n    end\r\n  end\r\n\r\n  x.compare!\r\nend\r\n\r\ni = 200\r\nj = 20..800\r\n\r\nBenchmark.ips do |x|\r\n  x.report('set_col_range - each') do\r\n    j.each do |j|\r\n      a[i][j] = 34\r\n    end\r\n  end\r\n\r\n  x.report('set_col_range - no each - Array.new') do\r\n    a[i][j] = Array.new(j.size, 34)\r\n  end\r\n\r\n\r\n  x.report('set_col_range - map!') do\r\n    a[i][j].map!{ 34 }\r\n  end\r\n\r\n  x.compare!\r\nend\r\n\r\ni = 1..800\r\nj = 6\r\n\r\nBenchmark.ips do |x|\r\n  x.report('set_row_range - each row') do\r\n    a[i].each do |i|\r\n      i[j] = 34\r\n    end\r\n  end\r\n\r\n  x.report('set_row_range - no each - map') do\r\n    a[i].map!{|e| e[j] = 34}\r\n  end\r\n\r\n  x.compare!\r\nend\r\n\r\nm = Matrix[[1,2,3,5,6]]\r\nv = [4,5,6,7,8,9,10,11,12,13,34]\r\ni = 0...5\r\n\r\nBenchmark.ips do |x|\r\n  x.report('set_range - matrix - each') do\r\n    m.each_with_index do |e, row, col|\r\n      r = i.first + col\r\n      v[r] = e\r\n    end\r\n  end\r\n\r\n  x.report('set_range - matrix - to_a') do\r\n    v[i] = m.to_a[0]\r\n  end\r\n\r\n  x.compare!\r\nend\r\n\r\nm = Matrix.build(0,1000){ |row, col| (row - col) * -13 }\r\nrows = Array.new(1000) { Array.new(2000) { rand(12..1567) }}\r\ni = 0..700\r\nj = 1000\r\n\r\nBenchmark.ips do |x|\r\n  x.report('set_row_range to column matrix - each_with_index') do\r\n    m.each_with_index do |e, row, col|\r\n      r = i.first + row\r\n      rows[r][j] = e\r\n    end\r\n  end\r\n\r\n  x.report('set_row_range to column matrix - map!') do\r\n    index = i.first\r\n    mat = m.column(0).to_a\r\n    rows[i].map!{|e| e[j] = mat[index]; index = index + 1 }\r\n  end\r\n\r\n  x.compare!\r\nend\r\n```\r\n\r\nThese are the outcomes:\r\n```\r\nComparison:\r\nset_row_and_col - one each and range - Array.new:     1475.0 i/s\r\nset_row_and_col - one each and range - map!:       26.0 i/s - 56.83x  slower\r\nset_row_and_col - double each:       19.9 i/s - 73.94x  slower\r\n\r\nComparison:\r\nset_col_range - no each - Array.new:   462402.6 i/s\r\nset_col_range - map!:    21274.2 i/s - 21.74x  slower\r\nset_col_range - each:    14141.7 i/s - 32.70x  slower\r\n\r\nComparison:\r\nset_row_range - each row:    14547.4 i/s\r\nset_row_range - no each - map:    13354.5 i/s - same-ish: difference falls within error\r\n\r\nComparison:\r\nset_range - matrix - to_a:  1260172.4 i/s\r\nset_range - matrix - each:   501323.9 i/s - 2.51x  slower\r\n\r\nComparison:\r\nset_row_range to column matrix - each_with_index:  1713121.2 i/s\r\nset_row_range to column matrix - map!:    12714.0 i/s - 134.74x  slower\r\n```", "created_at": "2018-01-25 17:47:02", "user": 17675583, "id": 360544455}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/360930337", "text": "@marcandre @Maumagnaguagno  any feedback on changes I've made?", "created_at": "2018-01-26 23:10:03", "user": 17675583, "id": 360930337}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/360944401", "text": "Good work.\r\n\r\nOne thing I notice: ranges like 2..-1 should be supported.\r\n\r\nStyle-wise, I'm not super enthusiastic at having so many private methods. For normal gems, I tend to do this, but standard lib style is usually \"simpler\" (for example with all the code in the same file) and I'd rather have the minimum number of private methods possible. If you want to keep the `raise_...` methods, they have to be renamed to something that describes better what they are doing (e.g. `check_...` or `insure_...`)", "created_at": "2018-01-27 00:47:47", "user": 33770, "id": 360944401}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361101156", "text": "I can't seem to understand how these ranges are supposed to work. I mean when I call `size` on `2..-1` I get `0` so I prepared my own way of getting the size of these ranges but I see it's wrong because `2..-1` doesn't correspond to array like this `[2, 1, 0, -1]`.  My example:\r\n```\r\na = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] \r\n=> [[1, 2, 3], [4, 5, 6], [7, 8, 9]] \r\ni = 2..-1\r\n=> 2..-1\r\na[1][2..-1]\r\n=> [6]\r\n```\r\n@marcandre could you explain how these ranges work and how I should tackle them?", "created_at": "2018-01-28 22:15:41", "user": 17675583, "id": 361101156}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361166579", "text": "You'll probably have to call `.begin`, `.end` and `.exclude_end?`", "created_at": "2018-01-29 07:59:41", "user": 33770, "id": 361166579}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361172339", "text": "I know that but the way I'm calculating size is wrong and I don't really understand how this should work. That's my current code:\r\n```\r\ndef range_size(range)\r\n    first = range.first\r\n    last = range.last\r\n    if first > last\r\n      if range.exclude_end?\r\n        first - (last + 1) + 1\r\n      else\r\n        first - last + 1\r\n      end\r\n    else\r\n      range.size\r\n    end\r\n  end\r\n```\r\nand when I execute this code:\r\n```\r\nm11 = Matrix[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\r\nm11[1, 2..-1] = 78\r\nMatrix[[1, 2, 3], [78, 78, 6], [7, 8, 9]] == m11\r\n```\r\nI get false because m11 becomes `Matrix[[1, 2, 3], [4, 5, 78, 78, 78, 78], [7, 8, 9]]` which is wrong because as I said I don't really know how these ranges work and why `2..-1` isn't equal to `2,1,0,-1` but only to `2,-1` or something? Could you at least shed some light on that? Is size just `begin/first + end/last` or what? ", "created_at": "2018-01-29 08:27:27", "user": 17675583, "id": 361172339}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361175483", "text": "`(a .. -2) <=> (a .. (size - 2) )`, so use `size + end - begin (+1?)`", "created_at": "2018-01-29 08:41:51", "user": 33770, "id": 361175483}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361596706", "text": "@marcandre done! I'm using `convert_range` to handle these ranges which doesn't require fixing every each and so on. I changed one thing in `set_row_and_col_range` because I noticed a mistake with setting matrices so I used the previous code fragment that works 100%.", "created_at": "2018-01-30 13:43:00", "user": 17675583, "id": 361596706}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361694103", "text": "Both methods `` range_within_count?`` and ``range_within_vector_range?`` use ``max <= (var - 1)`` which is equivalent to ``max < var``.", "created_at": "2018-01-30 18:47:02", "user": 11094484, "id": 361694103}, {"reactions": {"laugh": [11094484]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361704867", "text": "Thanks! Already corrected.", "created_at": "2018-01-30 19:22:43", "user": 17675583, "id": 361704867}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/362092864", "text": "@marcandre any thoughts or feedback? I reckon everything is fine and ready for merge. ", "created_at": "2018-01-31 22:29:41", "user": 17675583, "id": 362092864}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/362853915", "text": "@marcandre ping", "created_at": "2018-02-03 20:59:54", "user": 17675583, "id": 362853915}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/364204690", "text": "@marcandre I think is all done now", "created_at": "2018-02-08 18:28:28", "user": 17675583, "id": 364204690}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/364700339", "text": "@marcandre any feedback? After all these fixes it's probably ready to be merged.", "created_at": "2018-02-10 22:20:20", "user": 17675583, "id": 364700339}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/365049917", "text": "@marcandre ping", "created_at": "2018-02-12 20:22:04", "user": 17675583, "id": 365049917}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/366357539", "text": "@marcandre ping", "created_at": "2018-02-16 21:03:34", "user": 17675583, "id": 366357539}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/367399223", "text": "Sorry I haven't had time to look at it. Still in my todo list!", "created_at": "2018-02-21 17:10:55", "user": 33770, "id": 367399223}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/367425618", "text": "Okay, no worries. I just wanted to remind you.", "created_at": "2018-02-21 18:35:10", "user": 17675583, "id": 367425618}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/372051317", "text": "@marcandre Have you had time to take a look? ", "created_at": "2018-03-10 18:12:51", "user": 17675583, "id": 372051317}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/373509815", "text": "@marcandre ping", "created_at": "2018-03-15 20:20:11", "user": 17675583, "id": 373509815}, {"reactions": {"+1": [827143]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/373999191", "text": "@marcandre I really want to make sure my code is okay and ready to be merged so as to serve other matrix lovers. So if you've had a chance to look at it just let me know.", "created_at": "2018-03-18 13:28:26", "user": 17675583, "id": 373999191}], "assignees": [33770, 33770], "state": "open", "is-pull-request": true}, "292549691": {"text": "Vector#angle_with sometimes raises error with linearly dependent vectors:\r\n\r\n```\r\nrequire 'matrix'\r\nVector[6, 6].angle_with(Vector[7, 7]) # => Math::DomainError (Numerical argument is out of domain - \"acos\")\r\n```\r\n\r\nThis is due to rounding errors:\r\n\r\n```\r\nprod = magnitude * v.magnitude # =>  8.48528137423857 * 9.899494936611665 -> 83.99999999999999\r\nMath.acos(inner_product(v) / prod) # => Math.acos(84 / 83.99) -> Math.acos(1.0000000000000002)\r\n```\r\n\r\nThis patch explicitly return zero/Math::PI for linearly dependent vectors.", "labels": [], "number": 1803, "updated_at": "2018-02-23 03:07:44", "user": 9009981, "closed_at": null, "id": 292549691, "title": "Fix bug: Vector#angle_with with linearly dependent vectors", "url": "https://api.github.com/repos/ruby/ruby/issues/1803", "created_at": "2018-01-29 20:30:51", "comments": [{"reactions": {"+1": [23256836, 1050427]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361876285", "text": "\ud83d\udc4d \r\n\r\n@Saugardas please fix code style", "created_at": "2018-01-31 09:37:54", "user": 70792, "id": 361876285}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361891680", "text": "\ud83d\udc4d", "created_at": "2018-01-31 10:34:54", "user": 1050427, "id": 361891680}], "assignees": [], "state": "open", "is-pull-request": true}, "217484352": {"text": "Seems that LIKELY() introduces some penalties at branching.\r\n\r\n* Ruby 2.4.1\r\n```\r\n$ ruby -v ~/tmp/bench.rb\r\nruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-darwin16]\r\n       user     system      total        real\r\n   1.460000   0.010000   1.470000 (  1.462540)\r\n```\r\n\r\n* Ruby trunk without patch\r\n```\r\n$ ./miniruby -v -Ilib ~/tmp/bench.rb\r\nruby 2.5.0dev (2017-03-28 trunk 58156) [x86_64-darwin16]\r\n       user     system      total        real\r\n   1.580000   0.000000   1.580000 (  1.579428)\r\n```\r\n\r\n* Ruby trunk with patch\r\n```\r\n$ ./miniruby -v -Ilib ~/tmp/bench.rb\r\nruby 2.5.0dev (2017-03-28 trunk 58156) [x86_64-darwin16]\r\n       user     system      total        real\r\n   1.510000   0.000000   1.510000 (  1.505948)\r\n```\r\n\r\n* Test code\r\n```\r\nrequire 'benchmark'\r\n\r\nBenchmark.bm do |x|\r\n  ary = [1,2,3]\r\n\r\n  x.report do\r\n    20000000.times do\r\n      ary.at(2)\r\n    end\r\n  end\r\n\r\nend\r\n```", "labels": [], "number": 1556, "updated_at": "2018-02-23 03:07:32", "user": 199156, "closed_at": null, "id": 217484352, "title": "Fix one of performance regressions in method calling", "url": "https://api.github.com/repos/ruby/ruby/issues/1556", "created_at": "2017-03-28 08:29:58", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/290611970", "text": "Looks like that a lot of `nop` instructions also are invoked around `ruby_th_dtrace_setup()` with clang's generated binary when run same test codes.\r\n![](https://d3uepj124s5rcx.cloudfront.net/items/17023U0q290W1G0F1V1B/170331-0001.png?v=38690013)\r\n", "created_at": "2017-03-31 04:19:25", "user": 199156, "id": 290611970}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/291378857", "text": "Every time, Ruby checks whether DTrace's probe is enabled when it would call a method.\r\nHowever, DTrace's probe would not provided with dynamically, it is detected to provide at only compilation time.\r\n\r\n![](https://d3uepj124s5rcx.cloudfront.net/items/303c370C090f2v0t2V1V/170404-0001.png?v=ba555267)", "created_at": "2017-04-04 02:44:43", "user": 199156, "id": 291378857}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/291407077", "text": "Just a minor nit, but I think you mean probe, not prove.", "created_at": "2017-04-04 06:36:13", "user": 10236, "id": 291407077}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/291407971", "text": "@knu You're right. It was just typo. Thank you.", "created_at": "2017-04-04 06:41:02", "user": 199156, "id": 291407971}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302724174", "text": "This cannot disable probe once it is enabled.", "created_at": "2017-05-19 14:51:30", "user": 13423, "id": 302724174}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302858873", "text": "Looks for me that DTrace's probe will be enabled/disabled with `configure` script.\r\n\r\n1. If the system has `dtrace` command, `configure` will mark DTrace is availed.\r\n2. If DTrace is availed, DTrace's probe will be generated with `tool/gen_dummy_probes.rb` at `make` process.\r\n\r\nAnd there is no way to enable/disable DTrace's probe at runtime.\r\n\r\nHmm, I wonder If I missed something.", "created_at": "2017-05-20 08:15:16", "user": 199156, "id": 302858873}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302884207", "text": "There were some detailed documents about this mechanism before, but I couldn't find good document now. Therefore following are abstract of dtrace probes mechanism...\r\n\r\n* Whether probes are inserted into the binary or not is statically decided.\r\n  * It depends on the existence of `dtrace` command and configure as you wrote.\r\n  * Those probe is disabled by default (exist in the binary but don't fire event; many `NOP`s you saw are disabled probes) \r\n* Whether probes fire the event is dynamically decided\r\n  * Users can enable those probes by dtrace command. It dynamically replaces the `NOP`s in the memory with the related probe instructions.", "created_at": "2017-05-20 16:38:30", "user": 13423, "id": 302884207}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302910353", "text": "Thank you for replying.\r\nIt is very interesting mechanism and it sounds my changing is too bad.", "created_at": "2017-05-21 02:12:02", "user": 199156, "id": 302910353}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302920629", "text": "This still gain performance improvement?\r\nOn my environment it doesn't show significant change.", "created_at": "2017-05-21 07:36:00", "user": 13423, "id": 302920629}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302936771", "text": "It contains two modifications.\r\nCould you separate them?\r\n\r\nMethod calling is common operation so that we need to care about them.\r\nPlease make your benchmarks more carefully.\r\n\r\n", "created_at": "2017-05-21 13:29:39", "user": 9558, "id": 302936771}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303115845", "text": "```ruby\r\nrequire 'benchmark/ips'\r\n\r\nBenchmark.ips do |x|\r\n\r\n  x.report \"while\" do |iter|\r\n    ary = [1, 2, 3, 4, 5]\r\n    i = 0\r\n    while i < iter do\r\n      ary.at(2)\r\n      i += 1\r\n    end\r\n  end\r\n\r\n  x.report \"Integer#times\" do |iter|\r\n    ary = [1, 2, 3, 4, 5]\r\n    iter.times do\r\n      ary.at(2)\r\n    end\r\n  end\r\n\r\nend\r\n```", "created_at": "2017-05-22 14:26:16", "user": 199156, "id": 303115845}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303116233", "text": "## Benchmark result\r\nUsing Apple LLVM version 8.1.0 (clang-802.0.41)\r\n\r\n### Ruby 2.4.1\r\n```\r\n               while     20.988M (\u00b1 2.5%) i/s -    104.955M in   5.004269s\r\n       Integer#times     14.062M (\u00b1 3.0%) i/s -     70.306M in   5.004882s\r\n```\r\n\r\n### Before (r58192)\r\n```\r\n               while     20.937M (\u00b1 2.5%) i/s -    104.668M in   5.002974s\r\n       Integer#times     13.040M (\u00b1 1.9%) i/s -     65.238M in   5.005069s\r\n```\r\n\r\n* Result : ruby 2.4.1 vs r58192\r\n```\r\nwhile         -> 0.27 % down\r\nInteger#times -> 7.76 % down\r\n```\r\n\r\n### After (r58192 + patches)\r\n```\r\n               while     21.409M (\u00b1 3.0%) i/s -    107.055M in   5.005548s\r\n       Integer#times     13.159M (\u00b1 2.6%) i/s -     65.822M in   5.005854s\r\n```\r\n\r\n* Result : r58192 vs r58192 + patchs\r\n```\r\nwhile         -> 2.28 % up\r\nInteger#times -> 0.90 % up\r\n```", "created_at": "2017-05-22 14:27:36", "user": 199156, "id": 303116233}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303116525", "text": "## Benchmark result\r\nUsing gcc-7 (Homebrew GCC 7.1.0) 7.1.0\r\n\r\n### Ruby 2.4.1\r\n```\r\n               while     22.672M (\u00b1 2.3%) i/s -    113.292M in   5.000184s\r\n             16.818M (\u00b1 1.9%) i/s -     84.169M in   5.006644s\r\n```\r\n\r\n### Before (r58192)\r\n```\r\n               while     22.439M (\u00b1 2.0%) i/s -    112.208M in   5.002965s\r\n       Integer#times     16.613M (\u00b1 3.2%) i/s -     83.029M in   5.003500s\r\n```\r\n\r\n* Result : ruby 2.4.1 vs r58192\r\n```\r\nwhile         -> 0.97 % down\r\nInteger#times -> 1.37 % down\r\n```\r\n\r\n\r\n### After (r58192 + patches)\r\n```\r\n               while     22.893M (\u00b1 1.7%) i/s -    114.492M in   5.002894s\r\n       Integer#times     16.853M (\u00b1 1.8%) i/s -     84.302M in   5.004057s\r\n```\r\n\r\n* Result : r58192 vs r58192 + patchs\r\n```\r\nwhile         -> 2.04 % up\r\nInteger#times -> 1.53 % up\r\n```\r\n", "created_at": "2017-05-22 14:28:37", "user": 199156, "id": 303116525}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303116583", "text": "Updated benchmark script and result in above.\r\n\r\nI found,\r\n\r\n1. the regression is occurred in clang + Integer#times combination.\r\n2. The patches in this pull request increase performance very slightly.\r\n\r\nSo, I guess we need to focus on yield performance such as https://github.com/ruby/ruby/pull/1535", "created_at": "2017-05-22 14:28:53", "user": 199156, "id": 303116583}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303120485", "text": "This improvement is small but this simplifies code.\r\n(whether a patch should be merged or not depends the trade off between improvement and code complexity)\r\nIf this is also true on Linux+gcc, I'm positive to merge.\r\nHow do you think @ko1?", "created_at": "2017-05-22 14:42:10", "user": 13423, "id": 303120485}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303144269", "text": "(1) Please explain your environment. You only show your compiler, but you need to show your CPU arch (and OS if it is matter). On this case, \"LIKELY\" affects branch prediction and CPU arch is a matter (of course, compiler version are also matter). dtrace (systemtap) enable/disable is also matter.\r\n(2) Please show results in a table form. It is easy to compare.\r\n(3) (advanced) Please write the reason why these fix are affect your benchmark results. I'm not sure why such performance changing. I need to understand \"why\" to approve this PR.\r\n(4) Please explain why you change the benchmark. Benchmark should have the purpose and please make clear what is measured. Additionally, on this case, loop overhead is more matter so you need to measure only method call overhead. This is what I wrote \" Please make your benchmarks more carefully.\" in above message.\r\n\r\nThanks,\r\nKoichi", "created_at": "2017-05-22 16:03:03", "user": 9558, "id": 303144269}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303144604", "text": "> I need to understand \"why\" to approve this PR.\r\n\r\nIn other words, I'll check the reason sometime if nobody explains.", "created_at": "2017-05-22 16:04:18", "user": 9558, "id": 303144604}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303146171", "text": "I forgot one point.\r\n\r\n(5) (related to (3)) It contains two modification. Please separate and show which is matter for performance. I'm not sure about dtrace, but method caching seems good point to use `LIKELY`.\r\n", "created_at": "2017-05-22 16:09:37", "user": 9558, "id": 303146171}, {"reactions": {"+1": [1563960, 357288, 969118]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303349720", "text": "### 1. Environment\r\n* Hardware : MacBook Pro (Retina, 15-inch, Late 2013)\r\n* CPU : 2.6 GHz Intel Core i7 (Haswell)\r\n* OS : macOS 10.12.5\r\n* dtrace : macOS bundled `dtrace` command by default.\r\n* compiler\r\n    * clang 802.0.4 (in Xcode 8.3.1, maybe it is same with LLVM 3.9.1)\r\n    * gcc 7.1.0\r\n* Other : https://github.com/rugarciap/Turbo-Boost-Switcher to disable Turbo Boost feature in CPU\r\n\r\n### 2. Result\r\n* With clang\r\n\r\n|  | Ruby 2.4.1 | r58192 | Ruby 2.4.1 vs r58192 |  | Ruby 2.4.1 | r58192 + patches | Ruby 2.4.1 vs r58192 + patches |\r\n| --- | --- | --- | --- | --- | --- | --- | --- |\r\n| while | 104.955M | 104.668M | 0.27% down |  | 104.955M | 107.055M | 2.00% up |\r\n| Integer#times | 70.306M | 65.238M | 7.76% down |  | 70.306M | 65.822M | 6.81% down |\r\n\r\n* With gcc\r\n\r\n|  | Ruby 2.4.1 | r58192 | Ruby 2.4.1 vs r58192 |  | Ruby 2.4.1 | r58192 + patches | Ruby 2.4.1 vs r58192 + patches |\r\n| --- | --- | --- | --- | --- | --- | --- | --- |\r\n| while | 113.292M | 112.208M | 0.97% down |  | 113.292M | 114.492M | 1.06% up |\r\n| Integer#times | 84.169M | 83.029M | 1.37% down |  | 84.169M | 84.302M | 0.2% up |\r\n\r\n### 3. Explain the patch\r\nI've used `Instruments` which is developer tool contained in Xcode to measure the performace for each improvements.\r\n\r\nI was guessing that there is regression in method dispatching when I created the patches, and I investigated there.\r\n`Instruments` indicated `vm_exec -> vm_exec_core -> vm_call_cfunc -> Array#at` as function call graph for method dispathing.\r\n\r\n![](https://d2ppvlu71ri8gs.cloudfront.net/items/0H3K1e1n2K0o0h190r1Y/function_call_graph.png)\r\n\r\nEspecially, `vm_exec_core()` spent 4244 msec and `vm_call_cfunc()` spent 1179 msec in 6412 msec execution time and\r\nI thought they have the hotspots for method dispatching.\r\n\r\nNext, I investigate `vm_exec_core()` and `vm_call_cfunc()`. In `vm_exec_core()`, the largest hotspot is calling `vm_call_cfunc()` which spent `29.71%` of invoking `vm_exec_core()` (4244 msec). The second hotspot is around `UNLIKELY` which I changed in second patch.\r\n![](https://d2ppvlu71ri8gs.cloudfront.net/items/10082U0b2V1a3b433d0i/170523-0001.png)\r\n\r\nIf I removed `UNLIKELY`, it remove the second hotspot from `Instruments`.\r\n\r\nBy same way, I created a first patch for improving `vm_call_cfunc()`.\r\n\r\n\r\n### 4. Why change the benchmark\r\nThe first benchmark script uses Integer#times calling which has huge overhead.\r\nIn order to clarify whether really method dispatch has regression, I changed to use `while` loop.\r\n\r\n### 5. Separate and show which is matter for performance.\r\nI will try to do later, sorry.", "created_at": "2017-05-23 09:54:01", "user": 199156, "id": 303349720}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/303354402", "text": "### 3. Explain the patch (additional)\r\nUnder macOS, it has bundled `dtrace` command by default.\r\n\r\nI think the condition whether `dtrace` is enabled always returns `true`.\r\nSo, I guess `UNLIKELY` inserts some penalty in condition and then I removed.", "created_at": "2017-05-23 10:13:24", "user": 199156, "id": 303354402}], "assignees": [], "state": "open", "is-pull-request": true}, "274050632": {"text": "Feature [#14109](https://bugs.ruby-lang.org/issues/14109)\r\n\r\nDir.children is available since Feature [#11302](https://bugs.ruby-lang.org/issues/11302).\r\nFileUtils uses Dir.each on an internal method encapsulated on a private class `Entry_#entry`, having no '.' neither '..' entries would make now superfluous a chained reject filtering.\r\n\r\nThis change can improve the performance of these `FileUtils` methods when the provided path covers thousands of files or directories:\r\n\r\n- chmod_R\r\n- chown_R\r\n- remove_entry\r\n- remove_entry_secure\r\n- rm_r\r\n- remove_dir\r\n- copy_entry\r\n\r\nRelated: Feature #[13896](https://bugs.ruby-lang.org/issues/13896) ", "labels": [], "number": 1754, "updated_at": "2018-02-23 03:07:41", "user": 1037088, "closed_at": null, "id": 274050632, "title": "FileUtils : Use Dir.children instead of Dir.entries", "url": "https://api.github.com/repos/ruby/ruby/issues/1754", "created_at": "2017-11-15 06:41:07", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "110376011": {"text": "This PR optimizes the `gc_page_sweep` function.\n\nConsider the case of sweeping a string.\n\nIn case of trunk, the code path is: switch -> call obj_free -> switch -> switch -> call rb_str_free (note that obj_free does not get inlined even though it is marked as such).\nThis PR changes the code path to: call obj_free_string (via table lookup) -> jmp rb_str_free.\n\nOn my MacBook Pro using GCC 5.1.0, the following synthetic benchmark went from 7.57 sec. (trunk) to 7.21 sec (this PR).\n\n```\nrequire \"benchmark\"\nN = 100_000_000\nGC.start; GC.start # magic\nBenchmark.bm{|bm|\n  bm.report{N.times{str = \"a\"}}\n}\n```\n\nThe number of GC benchmarks changed as follows:\n\n| benchmark | trunk (user time / gc time) | this PR (user time / gc time) |\n| --- | --: | --: |\n| gcbench-rdoc | 97.5 / 5.27 | 95.0 / 5.15 |\n| gcbench-aobench | 72.3 / 4.15 | 69.3 / 3.98 |\n\nPlease take with a grain of salt when looking at the changes in user time; there were some variation between repetitive runs, and I am not sure why the numbers changed - does the incremental GC of ruby refer to some timer (in which case reduced number of sweep runs (as its faster) would lead to better CPU cache usage explaining the gain), or if not, it could be due to better use of branch prediction unit.\nOTOH the gc time numbers observed were mostly consistent.\n", "labels": [], "number": 1049, "updated_at": "2018-02-23 03:07:04", "user": 41567, "closed_at": null, "id": 110376011, "title": "optimize gc sweep", "url": "https://api.github.com/repos/ruby/ruby/issues/1049", "created_at": "2015-10-08 05:27:50", "comments": [{"reactions": {"+1": [41567]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/258613459", "text": "We'll need to employ this technique. Please give me a time for a while.\nSorry for waiting.\n", "created_at": "2016-11-05 14:01:44", "user": 9558, "id": 258613459}], "assignees": [9558, 9558], "state": "open", "is-pull-request": true}, "293038159": {"text": "This variable is expected to be an integer type which can be incremented\r\natomically.  Expected to be used where certain object's \"freshness\" is\r\nvital, e.g. when invalidating a cache.", "labels": [], "number": 1804, "updated_at": "2018-02-23 03:07:44", "user": 15377, "closed_at": null, "id": 293038159, "title": "new VM timestamp variable", "url": "https://api.github.com/repos/ruby/ruby/issues/1804", "created_at": "2018-01-31 05:44:30", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361833402", "text": "It is hard to justify this patch is acceptable or not without usecases.", "created_at": "2018-01-31 06:04:50", "user": 9558, "id": 361833402}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/361834202", "text": "This is a part of #1419.  Optimized instruction sequences are cached, then invalidated according to this variable.  For instance see https://github.com/ruby/ruby/pull/1419/commits/523120808bed6a54ced3cd8f17d1cf6a065678bf#diff-d52fa5b396928e0544140fd48f329543R126", "created_at": "2018-01-31 06:10:09", "user": 15377, "id": 361834202}], "assignees": [], "state": "open", "is-pull-request": true}, "254855763": {"text": "Currently CRuby warns \"regexp literal in condition\" for the following code.\r\n\r\n```ruby\r\nif /re/\r\nend\r\n\r\nif /#{x}re/\r\nend\r\n```\r\n\r\n```bash\r\n$ ruby -cw test.rb\r\ntest.rb:1: warning: regex literal in condition\r\ntest.rb:3: warning: regex literal in condition\r\nSyntax OK\r\n```\r\n\r\nHowever, CRuby does not warn for the following code.\r\n\r\n```ruby\r\n!/re/\r\n!/#{x}re/\r\n```\r\n\r\n```bash\r\n$ ruby -cw test.rb\r\nSyntax OK\r\n```\r\n\r\nI guess that this reason is that `!` can be redefined.\r\nHowever, the meaning of `!/re/` does not change with redefining.\r\n\r\n```ruby\r\n$_ = 're'\r\n\r\np(!/re/)\r\n\r\nclass Regexp\r\n  def !\r\n    p('redefined!')\r\n  end\r\nend\r\n\r\np(!/re/)\r\n```\r\n\r\n```bash\r\n$ ruby test.rb\r\nfalse\r\nfalse\r\n```\r\n\r\nSo, CRuby should warn for `!/re/`.", "labels": [], "number": 1694, "updated_at": "2018-02-23 03:07:38", "user": 4361134, "closed_at": null, "id": 254855763, "title": "Warn `!/re/`", "url": "https://api.github.com/repos/ruby/ruby/issues/1694", "created_at": "2017-09-03 05:57:12", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/326787049", "text": "`p(!/re/)` is not equivalent to `p(/re/.!)`. The code you showed calls Integer#!.\r\n\r\n~~~\r\n$ ruby --dump=i -e'p(!//)'\r\n== disasm: #<ISeq:<main>@-e>============================================\r\n0000 trace            1                                               (   1)\r\n0002 putself          \r\n0003 putobject        //\r\n0005 getspecial       0, 0\r\n0008 opt_regexpmatch2 <callinfo!mid:=~, argc:1, ARGS_SIMPLE>, <callcache>\r\n0011 opt_not          <callinfo!mid:!, argc:0, ARGS_SIMPLE>, <callcache>\r\n0014 opt_send_without_block <callinfo!mid:p, argc:1, FCALL|ARGS_SIMPLE>, <callcache>\r\n0017 leave            \r\n$ ruby --dump=i -e'p(//.!)'\r\n== disasm: #<ISeq:<main>@-e>============================================\r\n0000 trace            1                                               (   1)\r\n0002 putself          \r\n0003 putobject        //\r\n0005 opt_not          <callinfo!mid:!, argc:0, ARGS_SIMPLE>, <callcache>\r\n0008 opt_send_without_block <callinfo!mid:p, argc:1, FCALL|ARGS_SIMPLE>, <callcache>\r\n0011 leave            \r\n~~~", "created_at": "2017-09-03 06:25:44", "user": 1033740, "id": 326787049}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/326787473", "text": "> p(!/re/) is not equivalent to p(/re/.!). The code you showed calls Integer#!.\r\n\r\n\r\nYes, so i think CRuby should warns about `!/re/`, but it should not warn about `/re/.!`. And this change does not make it to warn about `/re/.!`.\r\n\r\n\r\n```ruby\r\n!/re/\r\n/re/.!\r\n```\r\n\r\n\r\n```bash\r\n$ ruby -W test.rb\r\ntest.rb:1: warning: regex literal in condition\r\n```", "created_at": "2017-09-03 06:40:23", "user": 4361134, "id": 326787473}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/326789273", "text": "I wanted to show that the fact `p(!/re/)` won't call Regexp#! doesn't immediately mean it can be folded into `false` at compile-time. Given that String#=~ and Integer#! can still be redefined, I don't think it makes sense to show such a warning.", "created_at": "2017-09-03 07:33:49", "user": 1033740, "id": 326789273}, {"reactions": {"laugh": [4361134]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/326789285", "text": "Ah, I was misunderstanding. The intention of the warning 'regex literal in condition' was to warn users of the implicit matching against $_. Sorry for the noise.", "created_at": "2017-09-03 07:34:05", "user": 1033740, "id": 326789285}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/331715633", "text": "I updated this pull-request. 1ca50fc\r\nThe commit changes warning message.\r\nbefore: \"regex literal in condition\"\r\nafter: \"the regex literal matches $_ implicitly\"\r\n\r\nBecause the warning message is hard to understand. ", "created_at": "2017-09-24 15:00:53", "user": 4361134, "id": 331715633}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/331715666", "text": "@nobu ping", "created_at": "2017-09-24 15:01:21", "user": 4361134, "id": 331715666}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/331761774", "text": "It seems reasonable to add a warning against `!/re/` expression, as an regexp literal in a boolean context.\r\nHowever, ruby/spec is backported to the upstream, so it should take care about previous versions.", "created_at": "2017-09-25 02:27:06", "user": 16700, "id": 331761774}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/332106944", "text": "> However, ruby/spec is backported to the upstream, so it should take care about previous versions.\r\n\r\nI updated the spec to use `ruby_version_is` to check RUBY_VERSION in 6c55bb4eb56931a674fb38405d8e34821efbdf93 .", "created_at": "2017-09-26 07:09:16", "user": 4361134, "id": 332106944}], "assignees": [], "state": "open", "is-pull-request": true}, "222243412": {"text": "This matches the documentation for `Enumerable::inject` and `Enumerable::reduce` which are also aliases.", "labels": [], "number": 1588, "updated_at": "2018-02-23 03:07:34", "user": 416575, "closed_at": null, "id": 222243412, "title": "Indicate `find_all` and `select` methods are aliases.", "url": "https://api.github.com/repos/ruby/ruby/issues/1588", "created_at": "2017-04-17 21:59:01", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "173261400": {"text": "There is a feature request open at: https://bugs.ruby-lang.org/issues/12700\n\nThis pull request adds regular expression heredocs to Ruby.\n\n``` ruby\nso /match\\s # first \nthese\\s       #second\nwords         # last\n/x\n```\n\ncan be replaced with\n\n```\n<</HEREDOC/x\nmatch\\s # first \nthese\\s       #second\nwords         # last\nHEREDOC\n\nthe '-' and '~' indentation works and switches can be applied.\n\nThe 'x' switch should be used in most cases.  There is a trailing `\\n` applied as in the string heredoc.\n\n```\n", "labels": [], "number": 1418, "updated_at": "2018-02-23 03:07:16", "user": 99491, "closed_at": null, "id": 173261400, "title": "Add Regexp Heredoc support", "url": "https://api.github.com/repos/ruby/ruby/issues/1418", "created_at": "2016-08-25 17:19:30", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/242875842", "text": "Please rebase.\nI wish it would be simpler now.\n", "created_at": "2016-08-26 23:29:49", "user": 16700, "id": 242875842}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/242976845", "text": "I have simplified the code, added new tests, removed a bug, and made the documentation more generic.\n", "created_at": "2016-08-28 14:09:14", "user": 99491, "id": 242976845}], "assignees": [], "state": "open", "is-pull-request": true}, "228479009": {"text": "Hi,\r\n\r\nI propose Hash#choice method.\r\n\r\nIt pick up key and value pairs in Hash like a below code.\r\n\r\n```ruby\r\n{ :a => 1, 2 => \"2\", \"c\" => true }.choice(:a, 2) # => { :a => 1, 2 => \"2\" }\r\n{ :a => 1, 2 => \"2\", \"c\" => true }.choice(\"c\", 10000) # => { \"c\" => true, 10000 => nil }\r\n```\r\n\r\nThis method is useful when Hash have many keys, but programer need few key's.\r\n\r\nFor instance, it pick up personal data in ActiveRecord model's data, and migrate to new device.\r\n\r\n```ruby\r\nfeature_phone_user = User.find(params[:src_user_id])\r\nprofile = feature_phone_user.attributes.choice(*%i[nickname email sex birthday prefecture])\r\nsmart_phone_user   = User.new\r\nsmart_phone_user.attributes = profile\r\n```\r\n\r\nIn other case, it pick up latest log from http request parameter.\r\n\r\n```ruby\r\ncondition = params.to_h.choice(\"user_id\", \"service_id\")\r\nlatest_payment_log = PaymentLog.find_by(condition).last\r\n```\r\n\r\nIf this method exist, I guess that many cases change to comfortable just a little.\r\n\r\nPlease think about it.\r\n", "labels": [], "number": 1613, "updated_at": "2018-02-23 03:07:35", "user": 854188, "closed_at": null, "id": 228479009, "title": "Implement Hash#choice method.", "url": "https://api.github.com/repos/ruby/ruby/issues/1613", "created_at": "2017-05-13 15:06:05", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/301254442", "text": "Please file a feature request at https://bugs.ruby-lang.org", "created_at": "2017-05-13 15:14:28", "user": 16700, "id": 301254442}], "assignees": [], "state": "open", "is-pull-request": true}, "216549485": {"text": "Add SO_REUSEADDR socket option for lib/drb/drb.rb. We had an issue with Fluentd (https://github.com/fluent/fluentd/blob/335d3b2b709ad368da6655636e8ab401b116ae4b/lib/fluent/plugin/in_debug_agent.rb#L55), which throws with error:\r\n\r\n```\r\n2017-03-20 07:18:45 +0000 [info]: listening dRuby uri=\"druby://127.0.0.1:24230\" object=\"Engine\"\r\n2017-03-20 07:18:45 +0000 [error]: unexpected error error_class=Errno::EADDRINUSE error=#<Errno::EADDRINUSE: Address already in use - bind(2) for \"127.0.0.1\" port 24230>\r\n  2017-03-20 07:18:45 +0000 [error]: /opt/td-agent/embedded/lib/ruby/2.1.0/drb/drb.rb:879:in `initialize'\r\n  2017-03-20 07:18:45 +0000 [error]: /opt/td-agent/embedded/lib/ruby/2.1.0/drb/drb.rb:879:in `open'\r\n  2017-03-20 07:18:45 +0000 [error]: /opt/td-agent/embedded/lib/ruby/2.1.0/drb/drb.rb:879:in `open_server'\r\n  2017-03-20 07:18:45 +0000 [error]: /opt/td-agent/embedded/lib/ruby/2.1.0/drb/drb.rb:764:in `block in open_server'\r\n  2017-03-20 07:18:45 +0000 [error]: /opt/td-agent/embedded/lib/ruby/2.1.0/drb/drb.rb:762:in `each'\r\n  2017-03-20 07:18:45 +0000 [error]: /opt/td-agent/embedded/lib/ruby/2.1.0/drb/drb.rb:762:in `open_server'\r\n  2017-03-20 07:18:45 +0000 [error]: /opt/td-agent/embedded/lib/ruby/2.1.0/drb/drb.rb:1373:in `initialize'\r\n  2017-03-20 07:18:45 +0000 [error]: /opt/td-agent/embedded/lib/ruby/gems/2.1.0/gems/fluentd-0.12.31/lib/fluent/plugin/in_debug_agent.rb:53:in `new'\r\n```\r\n\r\n```\r\n# ss -an | grep 24230\r\nTIME-WAIT  0      0                 127.0.0.1:24230            127.0.0.1:6380\r\n```\r\n\r\nWhen this is set on socket, TIME_WAIT socket can be ignored and reused, no need to wait until socket is cleaned up. ", "labels": [], "number": 1549, "updated_at": "2018-02-23 03:07:31", "user": 3352707, "closed_at": null, "id": 216549485, "title": "Add SO_REUSEADDR socket option for lib/drb/drb.rb", "url": "https://api.github.com/repos/ruby/ruby/issues/1549", "created_at": "2017-03-23 19:41:42", "comments": [], "assignees": [33682, 33682], "state": "open", "is-pull-request": true}, "251873905": {"text": "This is the successor of #1675 with the feedback of @nobu applied.\r\n\r\nTicket: https://bugs.ruby-lang.org/issues/13835", "labels": ["Bug"], "number": 1680, "updated_at": "2018-02-23 03:07:38", "user": 3873515, "closed_at": null, "id": 251873905, "title": "Fixed bug: Using 'open-uri' with 'tempfile' causes an exception.", "url": "https://api.github.com/repos/ruby/ruby/issues/1680", "created_at": "2017-08-22 08:17:19", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/324094612", "text": "Also, next time you open a PR, you can just rebase and force-push rather than creating a new PR. By doing so we can keep all the comments/reviews in one place, which makes it easier for others to track the discussion later.", "created_at": "2017-08-22 17:21:29", "user": 386234, "id": 324094612}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/324111665", "text": "Sorry - first time contributor. I'm still learning. I wasn't aware that I can rebase cross branches but will definitely try this approach next time. ", "created_at": "2017-08-22 18:25:14", "user": 3873515, "id": 324111665}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/324134175", "text": "@thorsteneckel not a problem at all! Feel free to ask any question here if you have any.", "created_at": "2017-08-22 19:55:56", "user": 386234, "id": 324134175}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/324238625", "text": "Thanks @yuki24 ! Actually I have one - which is a bit off topic. To avoid the confusion for contributors and organizational overhead for maintainers we use the [GitHub templates](https://github.com/blog/2111-issue-and-pull-request-templates) in our project. We ask some basic questions and provide information (like e.g. use the trunk branch for PR etc.). This can be added as a comment block and won't be visible in the final PR / doesn't need to get removed. Do you think I should create a pull request with the points I've already learned? Just a thought \ud83d\udca1 ", "created_at": "2017-08-23 06:54:24", "user": 3873515, "id": 324238625}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/324240975", "text": "Sie gehen heute per Post\n\nSent from my Windows 10 phone\n\nFrom: Thorsten\nSent: mercredi, 23 ao\u00fbt 2017 08:54\nTo: ruby/ruby\nCc: Subscribed\nSubject: Re: [ruby/ruby] Fixed bug: Using 'open-uri' with 'tempfile' causes anexception. (#1680)\n\nThanks @yuki24 ! Actually I have one - which is a bit off topic. To avoid the confusion for contributors and organizational overhead for maintainers we use the GitHub templates in our project. We ask some basic questions and provide information (like e.g. use the trunk branch for PR etc.). This can be added as a comment block and won't be visible in the final PR / doesn't need to get removed. Do you think I should create a pull request with the points I've already learned? Just a thought \ud83d\udca1\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n", "created_at": "2017-08-23 07:06:29", "user": 47452, "id": 324240975}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/324485415", "text": "@thorsteneckel thanks for your suggestion! I'm not sure if we have ever discussed adding issue templates - I'll bring that up to other committers. But as you mentioned, this is off topic, so feel free to make a new issue.", "created_at": "2017-08-23 22:55:37", "user": 386234, "id": 324485415}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/324583592", "text": "The current behavior is documented as:\r\n\r\n> If the first argument responds to the 'open' method, 'open' is called on\r\n> it with the rest of the arguments.\r\n\r\nand checking the arity seems so ad-hoc to me. I would prefer another way if we are making changes.\r\n\r\nThe original `Kernel#open` (implementation is in `io.c`, `rb_f_open()`) first of all checks whether the first argument responds to `to_open` or not, and redirects to that if it does. How about making open-uri's `open` handle `to_open` and then implementing `Tempfile#to_open` that directly calls File.open?\r\n\r\nIn any case, the doc has to be updated as well.", "created_at": "2017-08-24 09:28:05", "user": 1033740, "id": 324583592}], "assignees": [], "state": "open", "is-pull-request": true}, "219194487": {"text": "Patch for https://bugs.ruby-lang.org/issues/13396\r\n\r\n`Net::HTTP` currently has no way to timeout whatsoever while sending the HTTP request, if the server accept the TCP connection but never reads inside the socket, `Net::HTTP` can stay blocked forever.\r\n\r\nThis patch introduced a new `write_timeout` configuration, and change `BufferedIO#write` to use non-blocking IO.\r\n\r\nAs for chunked requests, since they use `IO.copy_stream`, I couldn't find another solution than to wrap it inside a `Timeout.timeout` block.\r\n", "labels": [], "number": 1575, "updated_at": "2018-02-23 03:07:34", "user": 19192189, "closed_at": null, "id": 219194487, "title": "Allow Net::HTTP to timeout if the remote server doesn't read the request fast enough", "url": "https://api.github.com/repos/ruby/ruby/issues/1575", "created_at": "2017-04-04 09:44:01", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/291459739", "text": "The build fails because of RubySpec, I've opened another PR here: https://github.com/ruby/spec/pull/415", "created_at": "2017-04-04 10:29:25", "user": 19192189, "id": 291459739}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302051981", "text": "@hsbt @sorah it would be great to know your opinion about HTTP write timeout.", "created_at": "2017-05-17 10:34:51", "user": 522155, "id": 302051981}], "assignees": [], "state": "open", "is-pull-request": true}, "307330680": {"text": "This PR is a first attempt to contribute to MRI, done at the RubyHackChallenge at Cookpad office in Bristol. I apologize in advance for anything that might be missing here, in relation to how this should be approached. \r\n\r\nIt has been started with https://github.com/ko1/rubyhackchallenge/issues/41. After the implementation, me and @skateman had a chart with @matz about the how applicable would it be to have that code merged.\r\n\r\nMatz suggested that a method like this, described afterwards in https://github.com/ko1/rubyhackchallenge/issues/44, would have more applicability and just generally be more useful.", "labels": [], "number": 1847, "updated_at": "2018-03-22 07:51:45", "user": 763630, "closed_at": null, "id": 307330680, "title": "Implement Hash#path_to_key", "url": "https://api.github.com/repos/ruby/ruby/issues/1847", "created_at": "2018-03-21 16:51:32", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/375016434", "text": "@skateman This is the implementation I came up with.", "created_at": "2018-03-21 16:56:07", "user": 763630, "id": 375016434}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/375019079", "text": "Where `h = {a: 1}`, both of `h.path_to_key(:a)` and `h.path_to_key(:b)` return `[]`.\r\nIs this intentional?\r\n\r\nFor recursive hash, `h = {}; h[:x] = h`, `h.path_to_key(:a)` returns `[:x]`, but `h` doesn't contain `:a`.", "created_at": "2018-03-21 17:03:06", "user": 16700, "id": 375019079}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/375023088", "text": "@nobu Interesting comment....\r\nNumber 1 is intentional, yes, although might not be the most ideal way of exposing that the path is unexistent _or_ it's in the first-level (root) of the Hash object.\r\n\r\nAbout number two, I will add a test for this case and fix it.", "created_at": "2018-03-21 17:13:52", "user": 763630, "id": 375023088}], "assignees": [], "state": "open", "is-pull-request": true}, "164423293": {"text": "PR for https://bugs.ruby-lang.org/issues/12573\n", "labels": [], "number": 1399, "updated_at": "2018-02-23 03:07:14", "user": 1298231, "closed_at": null, "id": 164423293, "title": "Create Process.exists? #12573", "url": "https://api.github.com/repos/ruby/ruby/issues/1399", "created_at": "2016-07-07 22:40:22", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/231248444", "text": "- What happens when we pass zero to it?\n- What about negative numbers?\n", "created_at": "2016-07-08 00:49:00", "user": 15377, "id": 231248444}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/231367737", "text": "Thank you very much for the feedback! I'll work on it and come back for the next round of comments.\n", "created_at": "2016-07-08 14:03:53", "user": 1298231, "id": 231367737}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/231376032", "text": "@shyouhei: It should behave the same as if the 0 or negative pid were passed to `Process.kill 0, pid` directly. Slightly modifying the docs for kill, the current behavior would be specified as:\n\n> Checks the existence of the specified process id if pid is positive. If pid is zero, all processes whose group ID is equal to the group ID of the process are checked.\n\nThe behavior for a negative number is defined by the Unix kill docs as:\n\n> If pid is -1, sig shall be sent to all processes (excluding an unspecified set of system processes) for which the process has permission to send that signal.\n> If pid is negative, but not -1, sig shall be sent to all processes (excluding an unspecified set of system processes) whose process group ID is equal to the absolute value of pid, and for which the process has permission to send a signal.\n\nWe can define an out of range type error if 0 or negative, since this doesn't really make sense in the case of `exist?`. I'm not sure what the right decision is here, please let me know what you think.\n", "created_at": "2016-07-08 14:35:08", "user": 1298231, "id": 231376032}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/231384900", "text": "I've updated the PR to fix this round of comments. If there are more comments, I'll address them, otherwise, what else should I do to get this decided upon?\n\nThanks!\n", "created_at": "2016-07-08 15:07:41", "user": 1298231, "id": 231384900}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/231531594", "text": "I've updated the code per your latest comments. Thanks!\n", "created_at": "2016-07-09 12:15:20", "user": 1298231, "id": 231531594}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/292985749", "text": "The `kill` method currently does not check whether the process you are signaling is defunct or not, this follows the behavior of the c lib and kill application to succeed on signaling defunct processes.\r\n\r\nLetting `exists?` return `true` for defunct processes however seems dangerous to me, nothing about the process is in existence except its entry in the process table. Using it to check if monitored processes are still alive would fail to restart defunct processes. \r\n\r\nWe suspect that this actually is the reason why the daemons gem (which uses the `kill(0, pid)` idiom) fails to gracefully restart job workers for us, but we are still investigating.", "created_at": "2017-04-10 15:30:25", "user": 123905, "id": 292985749}], "assignees": [], "state": "open", "is-pull-request": true}, "217824389": {"text": "These methods are for inspecting and modifying MRI's GC parameters. It may be\r\nuseful for realtime parameter tuning with GC.stat, user requests and so on.\r\n\r\nThis work is done by Tomohiro Moro (@slightair) and me (@makimoto).", "labels": [], "number": 1572, "updated_at": "2018-02-23 03:07:33", "user": 34493, "closed_at": null, "id": 217824389, "title": "gc.c: Add GC.get_parameters and .set_parameters", "url": "https://api.github.com/repos/ruby/ruby/issues/1572", "created_at": "2017-03-29 09:58:08", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/290043024", "text": "Please file an issue in bugs.ruby-lang.org, which is our canonical bug tracker and link this PR to the ticket, and vice versa.", "created_at": "2017-03-29 10:00:16", "user": 29440, "id": 290043024}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/290044252", "text": "@sorah done in https://bugs.ruby-lang.org/issues/13388 ", "created_at": "2017-03-29 10:05:16", "user": 34493, "id": 290044252}], "assignees": [], "state": "open", "is-pull-request": true}, "191364743": {"text": "This option allows a user to redirect command's stderr\r\nto the stdout and then to the stdin of the next command in a\r\npipeline. It's a very common use case to capture both\r\nstreams.", "labels": [], "number": 1490, "updated_at": "2018-02-23 03:07:24", "user": 1746846, "closed_at": null, "id": 191364743, "title": "Add :err => :out option for the open3 pipeline", "url": "https://api.github.com/repos/ruby/ruby/issues/1490", "created_at": "2016-11-23 19:46:33", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "269398664": {"text": "Introduce CAA RR DNS record on `Resolv`, defined in [RFC 6844](https://tools.ietf.org/html/rfc6844).\r\n\r\nChanges on the way `Resource::decode_rdata` works because CAA needs to know the\r\noverall RR length, which was previously swallowed.", "labels": [], "number": 1732, "updated_at": "2018-02-23 03:07:39", "user": 51246, "closed_at": null, "id": 269398664, "title": "CAA DNS\u00a0RR", "url": "https://api.github.com/repos/ruby/ruby/issues/1732", "created_at": "2017-10-29 13:20:54", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/340262283", "text": "I open [issue 14066](https://bugs.ruby-lang.org/issues/14066) on Redmine for that PR", "created_at": "2017-10-29 13:26:03", "user": 51246, "id": 340262283}], "assignees": [], "state": "open", "is-pull-request": true}, "303393934": {"text": "As file URLs cannot have username/password/port, we should not keep them when scheme is changed to file.\r\n\r\nRefs: https://github.com/whatwg/url/issues/259", "labels": [], "number": 1832, "updated_at": "2018-03-09 14:06:23", "user": 1716463, "closed_at": null, "id": 303393934, "title": "uri: restrict setting protocol to file scheme", "url": "https://api.github.com/repos/ruby/ruby/issues/1832", "created_at": "2018-03-08 08:23:59", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371431537", "text": "Isn\u2019t this dangerous? Allowing from another scheme to `file://` and keeping the path? IMO this should fail with a `SecurityError`. \r\n\r\nWhat\u2019s the use case?", "created_at": "2018-03-08 09:30:36", "user": 8876, "id": 371431537}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371439359", "text": "@paddor That's the current behaviour as you can try and this patch doesn't touch it.\r\n```ruby\r\nurl = URI.parse('http://user:pass@example.com')\r\nurl.scheme = 'file'\r\nputs url.to_s\r\n# => file://user:pass@example.com\r\n```\r\n\r\nFile URL can not have username, password and port, and this patch is just about how we handle it. It is possible to raise an error when `arg_check = true` at `_check` methods, but this change might be the smallest impact.", "created_at": "2018-03-08 09:59:55", "user": 1716463, "id": 371439359}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371766158", "text": "I'm just wondering, what's the use case? With or without this patch, setting the scheme to `file` while keeping the path seems dangerous to me.", "created_at": "2018-03-09 09:52:35", "user": 8876, "id": 371766158}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371787244", "text": "For example, it can use the path as file names when caching contents. If we specify the base URL, it is not dangerous so far.  I'm also interested in discussing how the path should be handled between `http` and `file`, but I think it should happen at `whatwg/url` instead since this behaviour is what is assumed by the spec.", "created_at": "2018-03-09 11:25:48", "user": 1716463, "id": 371787244}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371787886", "text": "// We might also be possible to open a new issue for it on the tracker :)", "created_at": "2018-03-09 11:28:49", "user": 1716463, "id": 371787886}, {"reactions": {"+1": [1716463]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371804091", "text": "This seems much safer and intuitive to me (path sanitizing not included):\r\n\r\n```\r\n[1] pry(main)> http_uri = URI 'http://example.com:8080/path/to/file.pdf'\r\n=> #<URI::HTTP http://example.com:8080/path/to/file.pdf>\r\n[2] pry(main)> file_uri = URI \"file://#{http_uri.path}\"\r\n=> #<URI::Generic file:///path/to/file.pdf>\r\n```\r\n\r\nI do think it's dangerous, because the path could contain `../../` and cause your cache to serve some other, possibly sensitive file, if you don't properly sanitize the path of the HTTP URI.", "created_at": "2018-03-09 12:51:07", "user": 8876, "id": 371804091}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371818221", "text": "In my understanding, that `../../ ` will be ignored if it's trying to go to the shallower directory than the base path, so it will not be that critical imo.\r\n\r\ne.g.\r\n```js\r\nnew URL('http://example.com/../../../foo/bar')\r\n// => http://example.com/foo/bar\r\n```\r\n\r\nEither way, that seems reasonable to ask at the specification repository about what properties the parser should keep when the scheme is changed between file and http. I'm also curious what @nurse think on this since he seems to work hard on the parser of URI.", "created_at": "2018-03-09 13:54:41", "user": 1716463, "id": 371818221}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371819570", "text": "It doesn't seem that way:\r\n\r\n```\r\n[1] pry(main)> URI 'http://example.com/../../../foo/bar'\r\n=> #<URI::HTTP http://example.com/../../../foo/bar>\r\n```", "created_at": "2018-03-09 14:00:06", "user": 8876, "id": 371819570}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/371821196", "text": "Wow really... Then I agree with you. Not a critical in a real world because of fewer use cases, but might not make sense to keep the path when the scheme is updated to file from http/https if we do not manage the relative path that can be shallower than the base path.", "created_at": "2018-03-09 14:06:23", "user": 1716463, "id": 371821196}], "assignees": [], "state": "open", "is-pull-request": true}, "284321901": {"text": "`RUBY_PATCHNAME` will return:\r\n\r\n- p{level}\r\n- dev\r\n- rc/preview labels\r\n\r\nThis is especially helpful when ruby is in\r\nrc/preview and `RUBY_PATCHLEVEL` is set to `-1`.\r\n\r\n`RUBY_PATCHNAME` is only a proposal name for the constant :)\r\nFeature request at https://bugs.ruby-lang.org/issues/14217", "labels": [], "number": 1780, "updated_at": "2018-02-23 03:07:42", "user": 1100970, "closed_at": null, "id": 284321901, "title": "Introduce RUBY_PATCHNAME constant", "url": "https://api.github.com/repos/ruby/ruby/issues/1780", "created_at": "2017-12-23 19:10:33", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "224024721": {"text": "At the internal calculation in Complex methods,\r\nit will just call Ruby #{+,-,*,/} methods via rb_funcall().\r\n\r\nThis patch will provide the optimization path for calculation\r\nusing #{+,-,/,*} methods for internal Fixnum objects.\r\n\r\n* Before\r\n```\r\nCalculating -------------------------------------\r\n           Complex#+      5.186M (\u00b1 4.9%) i/s -     25.937M in   5.013851s\r\n           Complex#-      5.209M (\u00b1 5.9%) i/s -     26.038M in   5.017972s\r\n           Complex#*      3.211M (\u00b1 5.2%) i/s -     16.170M in   5.051605s\r\n           Complex#/    537.251k (\u00b1 3.9%) i/s -      2.691M in   5.017513s\r\n          Complex#**      1.540M (\u00b1 3.0%) i/s -      7.726M in   5.019918s\r\n        Complex#abs2      7.050M (\u00b1 7.9%) i/s -     35.047M in   5.009324s\r\n```\r\n\r\n* After\r\n```\r\nCalculating -------------------------------------\r\n           Complex#+      7.265M (\u00b1 4.6%) i/s -     36.341M in   5.013803s\r\n           Complex#-      7.310M (\u00b1 4.5%) i/s -     36.540M in   5.009521s\r\n           Complex#*      6.402M (\u00b1 4.0%) i/s -     32.060M in   5.016835s\r\n           Complex#/    541.564k (\u00b1 3.3%) i/s -      2.744M in   5.072620s\r\n          Complex#**      1.490M (\u00b1 4.0%) i/s -      7.506M in   5.046460s\r\n        Complex#abs2     17.799M (\u00b1 6.6%) i/s -     88.688M in   5.007732s\r\n```\r\n\r\n* Test code\r\n```\r\nrequire 'benchmark/ips'\r\n\r\nBenchmark.ips do |x|\r\n  c1 = Complex(2, 3)\r\n  c2 = Complex(2, 3)\r\n\r\n  x.report \"Complex#+\" do |t|\r\n    t.times { c1 + c2 }\r\n  end\r\n\r\n  x.report \"Complex#-\" do |t|\r\n    t.times { c1 - c2 }\r\n  end\r\n\r\n  x.report \"Complex#*\" do |t|\r\n    t.times { c1 * c2 }\r\n  end\r\n\r\n  x.report \"Complex#/\" do |t|\r\n    t.times { c1 / c2 }\r\n  end\r\n\r\n  x.report \"Complex#**\" do |t|\r\n    t.times { c1 ** c2 }\r\n  end\r\n\r\n  x.report \"Complex#abs2\" do |t|\r\n    t.times { c1.abs2 }\r\n  end\r\nend\r\n```\r\n\r\nhttps://bugs.ruby-lang.org/issues/13506", "labels": [], "number": 1597, "updated_at": "2018-02-23 03:07:35", "user": 199156, "closed_at": null, "id": 224024721, "title": "Improve performance of Complex#{+,-,*,/,**,abs2}", "url": "https://api.github.com/repos/ruby/ruby/issues/1597", "created_at": "2017-04-25 05:23:30", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302726463", "text": "I don't know complex's performance improvement is worth increasing code complexity.", "created_at": "2017-05-19 14:59:55", "user": 13423, "id": 302726463}], "assignees": [], "state": "open", "is-pull-request": true}, "145398930": {"text": "Enumerable's `include?` calls `each` until a matching value is found. This means `Prime.include?` will not terminate for composite arguments. The solution is override `Prime.include?` to alias the existing `Prime.prime?`, to better implement the Enumerable interface.\n", "labels": [], "number": 1317, "updated_at": "2018-02-23 03:07:11", "user": 1191970, "closed_at": null, "id": 145398930, "title": "Override Prime.include? to avoid nontermination", "url": "https://api.github.com/repos/ruby/ruby/issues/1317", "created_at": "2016-04-02 18:00:51", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/204770092", "text": "Related bug report: [Prime#include?(mod) hangs up](https://bugs.ruby-lang.org/issues/10167)\n", "created_at": "2016-04-02 18:23:27", "user": 212792, "id": 204770092}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/204770922", "text": "Related, but `include?` to detect an included module is not standard. Use `self.class.included_modules.include?` instead. In this patch, `Prime.include? Enumerable` results in an `ArgumentError`, which is fine. It's also a one-liner.\n", "created_at": "2016-04-02 18:36:50", "user": 1191970, "id": 204770922}], "assignees": [], "state": "open", "is-pull-request": true}, "273792147": {"text": "The `^` operator in `Set` is commonly known as _ exclusive or_ and _XOR_ in mathematics, hardware and other programming languages. Adding _xor_ as an alias makes it much more readable and explicit and that is what we love of Ruby. \u2764\ufe0f\r\n\r\nI also added to the documentation of `^`. \r\n\r\n\r\n", "labels": [], "number": 1753, "updated_at": "2018-02-23 03:07:40", "user": 16052290, "closed_at": null, "id": 273792147, "title": "Set#^ is XOR", "url": "https://api.github.com/repos/ruby/ruby/issues/1753", "created_at": "2017-11-14 13:28:09", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "184121508": {"text": "The iso 8601 spec allows for omission of the 'day' part of a date\nrepresentation. However, because it also allows omission of the month in\nthe case of `YYYY-DDD` (where `DDD` represents the day-of-year), there\nis some abiguity.\n\nIf there are only two components, a four-digit year,\nfollowed by a dash (`-`) followed by another series of digits, the\ndisambiguation is as follows:\n- If there are two digits in the second component, that component\n  represents the month.\n- If there are three digits in the second component, that component\n  represents the day-of-year.\n\nThe existing implementation has affordances for many things that are not\nconsistent with iso 8601. Rather than make a large,\nbackwards-incompatible change, I thought it best to fix this one edge\ncase.\n\nhttps://bugs.ruby-lang.org/issues/12833\n", "labels": [], "number": 1463, "updated_at": "2018-02-23 03:07:21", "user": 2222374, "closed_at": null, "id": 184121508, "title": "Add support for iso8601 `YYYY-MM` format", "url": "https://api.github.com/repos/ruby/ruby/issues/1463", "created_at": "2016-10-20 02:38:40", "comments": [{"reactions": {"+1": [2222374, 131620]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/254996920", "text": "It looks like there was a network error in AppVeyor when attempting to download zlib 1.2.8 from sourceforge. Someone with the correct permissions probably needs to run AppVeyor again, since the failure appears to be non-deterministic.\n\n```\nappveyor DownloadFile http://downloads.sourceforge.net/project/libpng/zlib/1.2.8/zlib128.zip\nError downloading remote file: One or more errors occurred.\nInner Exception: Unable to connect to the remote server\nCommand exited with code 2\n```\n\n![image](https://cloud.githubusercontent.com/assets/345018/19544806/28d7d3d4-9647-11e6-9fd8-ae13179b5b35.png)\n", "created_at": "2016-10-20 03:00:46", "user": 345018, "id": 254996920}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/255123361", "text": "\ud83d\udc4d I am always for stricter adherence to standards. Tests pass on Travis and the code looks good to me.\n", "created_at": "2016-10-20 14:33:59", "user": 131620, "id": 255123361}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/255537935", "text": "This might be frowned upon, but a rebase to latest `trunk` and `push -f` triggered a successful (re-) build.\n", "created_at": "2016-10-22 16:23:24", "user": 2222374, "id": 255537935}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/278962973", "text": "FWIW, https://github.com/arnau/ISO8601/blob/master/docs/date-time.md provides what I need. It would be slightly better if that gem allowed for monkey-patching the core `date` module to 'repair' it.", "created_at": "2017-02-10 14:51:18", "user": 2222374, "id": 278962973}], "assignees": [], "state": "open", "is-pull-request": true}, "176234661": {"text": "`FileUtils.cp_r` does not detect copying a directory to itself if either the source or destination contains a dot (`.`). Depending on order and platform, this can cause different errors like `File name too long` or `unknown file type` or just stack overflow.\n\nThis patch changes the current dynamic regex approach to comparing absolute paths.\n\nThe test commands in the Travis CI config did not show test failure for me, but `make test-all TESTOPTS=\"-q -- test/fileutils/test_fileutils.rb\"` with the new tests but without the changes to `descendant_directory?` shows the failure clearly.\n\nExample of not detecting same directory:\n<details>\n  <summary>\n\nClick for example</summary>\n\n\n\n```\n2.3.1 :001 > require 'fileutils'\n => true \n2.3.1 :002 > FileUtils.cp_r 'test_rec', './test_rec'\nErrno::ENAMETOOLONG: File name too long @ dir_s_mkdir - ./test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec/test_rec\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1366:in `mkdir'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1366:in `copy'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:472:in `block in copy_entry'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1498:in `wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1501:in `block in wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `each'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1501:in `block in wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `each'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1501:in `block in wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `each'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1501:in `block in wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `each'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `wrap_traverse'\n... 1339 levels...\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `each'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1501:in `block in wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `each'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1501:in `block in wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `each'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1500:in `wrap_traverse'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:469:in `copy_entry'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:444:in `block in cp_r'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1571:in `block in fu_each_src_dest'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1585:in `fu_each_src_dest0'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:1569:in `fu_each_src_dest'\n    from /home/justin/.rvm/rubies/ruby-2.3.1/lib/ruby/2.3.0/fileutils.rb:443:in `cp_r'\n    from (irb):2\n    from /home/justin/.rvm/rubies/ruby-2.3.1/bin/irb:11:in `<main>'\n```\n\n</details>\n", "labels": [], "number": 1425, "updated_at": "2018-02-23 03:07:18", "user": 75613, "closed_at": null, "id": 176234661, "title": "Improve same directory detection in FileUtils", "url": "https://api.github.com/repos/ruby/ruby/issues/1425", "created_at": "2016-09-11 09:26:41", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "256157865": {"text": "Insert __AFL_INIT() so that AFL can defer snapshotting process image.\r\nThis speeds up AFL from 75.57 exec/sec to 1225 exec/sec on my machine.\r\n\r\nAs of writing you need to compile using afl-clang-fast compiler\r\nfrontend, and run ruby with afl-fuzz.  Consult [AFL's document](https://github.com/mirrorer/afl/blob/master/llvm_mode/README.llvm) for more\r\ninfo.", "labels": [], "number": 1695, "updated_at": "2018-02-23 03:07:38", "user": 15377, "closed_at": null, "id": 256157865, "title": "Support American Fuzzy Lop", "url": "https://api.github.com/repos/ruby/ruby/issues/1695", "created_at": "2017-09-08 06:55:00", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/338830777", "text": "@shyouhei I tried to use your solution, but I don't seem to gain any speed. \r\nI get good speed improvements by using this modified version of `main.c`: \r\nhttps://gist.github.com/clod81/6f1b9f3e23ac2d8200fd2139503ce5d9\r\n\r\nTo be specific, I tried to compile Ruby version 2.4.2 with the change you suggested, as per: https://gist.github.com/clod81/531eda153b06eb3f75510e42a86f3166 , but again, no speed improvement there.", "created_at": "2017-10-24 00:00:57", "user": 1020921, "id": 338830777}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/340389062", "text": "@clod81 Thank you.\r\n\r\nHowever your proposed `main.c` seems inappropriate because `ruby_options()` can run arbitrary ruby script including threads and/or child process creations, IO operations, and timer manipulations.  They are prohibited by the AFL document I mentioned above.  `__AFL_INIT();` must be inserted much earlier.\r\n\r\nAnd I guess that relates to the reason your test does not gain speed up; perhaps you specified some heavay-lifting command line options like `-r rails` ?", "created_at": "2017-10-30 09:28:59", "user": 15377, "id": 340389062}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/340550844", "text": "@shyouhei no, I was just trying `ruby` alone. For example, when calling Marshal.load, with my setup it on my machine it was running with around 500 execs per sec, with this setup, around 10 or 20 (I will need to double check that). I will try to setup a docker image later today with your proposed setup, and we can try it out.", "created_at": "2017-10-30 19:03:12", "user": 1020921, "id": 340550844}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/340565006", "text": "@shirosaki \r\n\r\nHere a docker image with the setup you suggested:\r\n- https://hub.docker.com/r/clod81/afl-ruby-2.4.2-persist-in-ruby.c\r\n\r\nThis one with my attempt:\r\n- https://hub.docker.com/r/clod81/afl-ruby2.4.2\r\n\r\nI've been using my setup to fuzz a few gems with C extensions, and I didn't have any issue with it\r\n", "created_at": "2017-10-30 19:55:38", "user": 1020921, "id": 340565006}], "assignees": [], "state": "open", "is-pull-request": true}, "198270407": {"text": "Why not?\r\n\r\nI think `Enumerable#each_cons` and `Enumerable#each_slice` are extensions of `each` method, so to return a receiver looks a natural behavior.", "labels": [], "number": 1509, "updated_at": "2018-02-23 03:07:28", "user": 6679325, "closed_at": null, "id": 198270407, "title": "Fix Enumerable#each_cons and each_slice to return a receiver", "url": "https://api.github.com/repos/ruby/ruby/issues/1509", "created_at": "2017-01-01 15:10:47", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/270592855", "text": "What should I make [CI successful](https://travis-ci.org/ruby/ruby/builds/188136640) for?", "created_at": "2017-01-05 08:48:50", "user": 6679325, "id": 270592855}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/270624470", "text": "Make a branch with version guards and send a pull request to https://github.com/ruby/spec.\r\nThen check out that branch before `make update-rubyspec` at the end of `before_script` section in `.travis.yml` file.", "created_at": "2017-01-05 11:34:05", "user": 16700, "id": 270624470}], "assignees": [], "state": "open", "is-pull-request": true}, "197896876": {"text": "* ticket: https://bugs.ruby-lang.org/issues/13083\r\n* spec: https://github.com/ruby/spec/pull/380", "labels": [], "number": 1506, "updated_at": "2018-02-23 03:07:26", "user": 1180335, "closed_at": null, "id": 197896876, "title": "[WIP] {String|Symbol}#match{?} with nil returns falsy as Regexp#match{?}", "url": "https://api.github.com/repos/ruby/ruby/issues/1506", "created_at": "2016-12-28 18:34:04", "comments": [{"reactions": {"+1": [1180335]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354314909", "text": "@kachick Could you update based on matz's feedback in https://bugs.ruby-lang.org/issues/13083?\r\nSo `Regexp#match` and `Regexp#match?` should raise TypeError when passed `nil`.\r\nBTW, you can change specs directly in this PR.", "created_at": "2017-12-28 16:25:27", "user": 168854, "id": 354314909}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354317989", "text": "Sorry for 1 year pending to update.... :bow: :bow:", "created_at": "2017-12-28 16:44:32", "user": 1180335, "id": 354317989}], "assignees": [], "state": "open", "is-pull-request": true}, "236645552": {"text": "I would like to let `Delegator` dump itself instead of the delegated object. Let's consider the following scenario.\r\n\r\n```\r\nrequire \"delegate\"\r\n\r\nclass Foo < Delegator\r\n  def initialize(the_obj)\r\n    @the_obj = the_obj\r\n  end\r\n\r\n  def __getobj__\r\n    @the_obj\r\n  end\r\nend\r\n\r\nfoo = Foo.new(nil)\r\nfoo.inspect\r\n# nil\r\n```\r\n\r\nThis dump message might cause confusion because `foo` object itself is not `nil`. Why don't we be clear and have a dump message like \"foo is an Foo class with `nil` as the delegated object\"?", "labels": [], "number": 1653, "updated_at": "2018-02-23 03:07:37", "user": 5930347, "closed_at": null, "id": 236645552, "title": "Dump Delegator itself instead of the delegated", "url": "https://api.github.com/repos/ruby/ruby/issues/1653", "created_at": "2017-06-17 07:34:04", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/309655219", "text": "Polite ping :), any ideas on this PR?", "created_at": "2017-06-20 06:15:05", "user": 5930347, "id": 309655219}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/313845224", "text": "Another polite ping! Hello Captain!!!", "created_at": "2017-07-08 09:26:24", "user": 5930347, "id": 313845224}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/313845529", "text": "Could you file a feature request to https://bugs.ruby-lang.org first?", "created_at": "2017-07-08 09:34:29", "user": 3138447, "id": 313845529}, {"reactions": {"+1": [3138447, 3312462, 969118]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/313845865", "text": "@k0kubun thanks, I have submitted a ticket at https://bugs.ruby-lang.org/issues/13733?", "created_at": "2017-07-08 09:43:17", "user": 5930347, "id": 313845865}], "assignees": [], "state": "open", "is-pull-request": true}, "212039857": {"text": "Time#== will be faster around 40%.\r\n\r\n* Before\r\n```\r\n              user     system      total        real\r\nTime#==   1.940000   0.000000   1.940000 (  1.950250)\r\n```\r\n\r\n* After\r\n```\r\n              user     system      total        real\r\nTime#==   1.340000   0.010000   1.350000 (  1.348283)\r\n```\r\n\r\n* Test code\r\n```\r\nrequire 'benchmark'\r\n\r\nBenchmark.bmbm do |x|\r\n  x.report \"Time#==\" do\r\n    t = Time.now\r\n    2000000.times do\r\n      t == Time.now\r\n    end\r\n  end\r\nend\r\n```\r\n", "labels": [], "number": 1532, "updated_at": "2018-02-23 03:07:30", "user": 199156, "closed_at": null, "id": 212039857, "title": "Improve Time#== performance", "url": "https://api.github.com/repos/ruby/ruby/issues/1532", "created_at": "2017-03-06 07:03:58", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/284320129", "text": "build fail of appveyor is not related this pull request. After it fixed, I will re-run appveyor build.", "created_at": "2017-03-06 07:18:50", "user": 12301, "id": 284320129}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/284320710", "text": "Why not overriding `Time#==`?\r\nWhy should `Comparable` take care of `Time` only?", "created_at": "2017-03-06 07:22:39", "user": 16700, "id": 284320710}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/284322958", "text": "Users can override Time#<=> and then the behavior of Time#== should follow its method, I guess.\r\nSo, I didn't override Time#==.\r\n\r\nIf there is way to detect recursive check, It should be used in here. Sorry, I didn't know that. \r\n", "created_at": "2017-03-06 07:37:33", "user": 199156, "id": 284322958}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/284323672", "text": "@Watson1978 Can you rebase to https://github.com/ruby/ruby/commit/5e62a1bd2988529490baaff3149f12d812a6a5ea ?", "created_at": "2017-03-06 07:41:44", "user": 12301, "id": 284323672}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302716220", "text": "How about overriding `Time#==` which checks `Time#<=>` is override or not.", "created_at": "2017-05-19 14:22:18", "user": 13423, "id": 302716220}], "assignees": [], "state": "open", "is-pull-request": true}, "202353330": {"text": "", "labels": [], "number": 1518, "updated_at": "2018-02-23 03:07:28", "user": 236550, "closed_at": null, "id": 202353330, "title": "Make prettyprint\u2019s cycle detection aware of Delegator instances. Fixes #13144.", "url": "https://api.github.com/repos/ruby/ruby/issues/1518", "created_at": "2017-01-22 01:56:24", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "289191092": {"text": "[Feature #13884](https://bugs.ruby-lang.org/issues/13884) added some improvements to `and`, `or` and `diff` operations, and also new assertions grouped on their own namespace, some of those assertions needed to be removed from `test_MINUS` since are already on `test_MINUS_big_array`:\r\nhttps://github.com/ruby/ruby/blob/42bb73cf64bc4a122b80eb2262f5b9c47381a024/test/ruby/test_array.rb#L260-L264\r\n\r\nhttps://github.com/ruby/ruby/blob/42bb73cf64bc4a122b80eb2262f5b9c47381a024/test/ruby/test_array.rb#L275-L279\r\n", "labels": [], "number": 1790, "updated_at": "2018-02-23 03:07:43", "user": 1037088, "closed_at": null, "id": 289191092, "title": "Removing duplicated assertions on test_array.rb - MINUS method", "url": "https://api.github.com/repos/ruby/ruby/issues/1790", "created_at": "2018-01-17 09:12:34", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "228084406": {"text": "\"locale encoding\" is misleading since it doesn't mean Encoding.find(\"locale\")\r\nbut the encoding used to interpret the script file. It's therefore better to\r\ncall it \"script encoding\" as in the paragraphs above.", "labels": [], "number": 1611, "updated_at": "2018-02-23 03:07:35", "user": 176234, "closed_at": null, "id": 228084406, "title": "Better wording for __ENCODING__", "url": "https://api.github.com/repos/ruby/ruby/issues/1611", "created_at": "2017-05-11 18:41:25", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "272929976": {"text": "I introduce a `union` method equivalent to the `|` operator, but which accept more than one array as argument. This improved readability, and it is also coherent with the `+` operator, which has a similar `concat` method. The method doesn't modify the original object and return a new object instead. :smile: I plan to send a PR for the `union!` method as well. :wink: \r\n\r\nTests are included, although there is no documentation (or I didn't find it) about how Ruby is tested, so I am not sure if I need to test this somewhere else or/and in any other way.\r\n\r\nI also didn't find any documentation regarding how the changelog is created, how the project is documented and the style that the code follows. Is there any documentation? Should I modify something? :thinking: \r\n\r\nThis solves partially https://bugs.ruby-lang.org/issues/14097", "labels": [], "number": 1747, "updated_at": "2018-02-23 03:07:40", "user": 16052290, "closed_at": null, "id": 272929976, "title": "Add union method to Array", "url": "https://api.github.com/repos/ruby/ruby/issues/1747", "created_at": "2017-11-10 13:19:38", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/343880430", "text": "@nobu thanks for your comments. :blush:\r\n\r\nI am not pretty sure what you mean with this: \ud83e\udd14 \r\n\r\n \r\n>>``` Ruby\r\n>>for (i = 0; i < argc; i++) sum += RARRAY_LEN(argv[i]);\r\n>>```\r\n> Non array argument causes a segfault.\r\n\r\n", "created_at": "2017-11-13 10:42:11", "user": 16052290, "id": 343880430}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/343926441", "text": "I added this to NEWS, I hope it is the way the CHANGELOG is managed. \ud83d\ude09 ", "created_at": "2017-11-13 13:58:25", "user": 16052290, "id": 343926441}, {"reactions": {"+1": [16052290]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/344122097", "text": "> I am not pretty sure what you mean with this: \ud83e\udd14\r\n\r\nFor instance, `[].union(nil)` segfaults.\r\nArguments should be converted by `to_ary()`.", "created_at": "2017-11-14 02:04:48", "user": 16700, "id": 344122097}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/344212892", "text": "@nobu changes made! thanks!\r\n\r\nAnother thing, I wrote similar tests for `union` as for `|`, but there are two tests for `|` (`test_OR_in_order` and `test_OR_big_in_order` that I am not sure why are needed, so I didn't replicate them. What are these two test testing?", "created_at": "2017-11-14 10:24:03", "user": 16052290, "id": 344212892}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/344906079", "text": "@nobu do I need to change something else? \ud83e\udd14 ", "created_at": "2017-11-16 12:16:31", "user": 16052290, "id": 344906079}], "assignees": [], "state": "open", "is-pull-request": true}, "183351071": {"text": "Hi!\n\nI added a DTrace probe on the constant cache clear, it's basically the same thing @tmm1 did for the method cache.\nThis helped me to debug some apps, consider a merge if it's interesting!\n\nCheers\n", "labels": [], "number": 1462, "updated_at": "2018-02-23 03:07:20", "user": 557414, "closed_at": null, "id": 183351071, "title": "vm_method.c: add new ruby::constant-cache-clear dtrace probe", "url": "https://api.github.com/repos/ruby/ruby/issues/1462", "created_at": "2016-10-17 08:09:31", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "127297218": {"text": "I previously opened this: https://github.com/ruby/ruby/pull/1200\n\nThis PR introduces similar performance improvements for 'immediate' (Fixnum, floats, etc..) values, whilst not changing behaviour for `Float::NAN` or objects with redefined `eql?` methods.\n\n_caveat:_ This does change behaviour if you monkey patch the `eql?` method for an immedate value class, but if you're doing that, I imagine Array#eql? is going to be low down on your list of problems.\n## Benchmarks\n\nMarked improvement for arrays of immediate values: https://gist.github.com/dwfait/da225dcc4687dcaff2a5\n\nNo apparent degradation of performance for arrays of objects / non-immediate values: https://gist.github.com/dwfait/9add4b6442897d68a2cd\n## Float::NAN\n\nAs mentioned, in this PR treatment of Float::NAN is as before:\n\n```\nirb(main):001:0> [Float::NAN].eql? [Float::NAN]\n=> false\n```\n\nHowever, I did not create a test for this, because Matz has stated comparison of NaN to NaN is undefined: https://bugs.ruby-lang.org/issues/1720\n\nI have however included a test which I believe addresses the core of that issue - of objects where `eql?` will return false, even to itself.\n", "labels": [], "number": 1206, "updated_at": "2018-02-23 03:07:06", "user": 1858956, "closed_at": null, "id": 127297218, "title": "array.c: eql? identity check if immediate value", "url": "https://api.github.com/repos/ruby/ruby/issues/1206", "created_at": "2016-01-18 19:42:25", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "217129668": {"text": "The declaration of local variable in loop, it will initialize local variable for each run of the loop with clang generated code.\r\nSo, it shouldn't declare the local variable in heavy loop.\r\n\r\nArray#sum with float elements will be faster around 30%.\r\n\r\n* Before\r\n```\r\n       user     system      total        real\r\n   3.320000   0.010000   3.330000 (  3.336088)\r\n```\r\n\r\n* After\r\n```\r\n       user     system      total        real\r\n   2.590000   0.010000   2.600000 (  2.602399)\r\n```\r\n\r\n* Test code\r\n```\r\nrequire 'benchmark'\r\n\r\nBenchmark.bmbm do |x|\r\n  ary = []\r\n  10000.times { ary << Random.rand }\r\n\r\n  x.report do\r\n    50000.times do\r\n      ary.sum\r\n    end\r\n  end\r\n\r\nend\r\n```\r\n\r\nhttps://bugs.ruby-lang.org/issues/13368", "labels": [], "number": 1555, "updated_at": "2018-02-23 03:07:32", "user": 199156, "closed_at": null, "id": 217129668, "title": "Improve performance of Array#sum with float elements", "url": "https://api.github.com/repos/ruby/ruby/issues/1555", "created_at": "2017-03-27 03:49:14", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "187555015": {"text": "If you want to configure SMTP for sending emails with SMTP Auth in Rails or directly via Net::SMTP you need to define the accepted auth type of the smtp server (which is complicated and need some experience to find out what you need to enter). Most SMTP servers work with \"plain\" (currently the default auth type of Net::SMTP) but for exchange (also Office365) you need to use \"login\". \r\n\r\nTo make the config easier this pull request adds auto detection of supported auth types for SMTP server and use first working auth type.\r\n\r\n -=> So no auth type option need to be set in Rails / Net::SMTP unless you really want to use a certain auth type.", "labels": [], "number": 1474, "updated_at": "2018-03-12 05:54:15", "user": 110226, "closed_at": null, "id": 187555015, "title": "Added auto detected of authentication type based on smtp server capabilities.", "url": "https://api.github.com/repos/ruby/ruby/issues/1474", "created_at": "2016-11-06 11:06:36", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/258795292", "text": "Nice! Actually it would be interesting in which order the checks should get performed. Imho the most secure one should be the one first tried and so on...\n", "created_at": "2016-11-07 10:10:03", "user": 3873515, "id": 258795292}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/372200870", "text": "Doesn\u2019t look like this was ever merged?", "created_at": "2018-03-12 05:54:15", "user": 16469772, "id": 372200870}], "assignees": [], "state": "open", "is-pull-request": true}, "296001226": {"text": "", "labels": [], "number": 1812, "updated_at": "2018-02-23 03:07:44", "user": 740289, "closed_at": null, "id": 296001226, "title": "[Docs] Show alphanumeric example in module docs", "url": "https://api.github.com/repos/ruby/ruby/issues/1812", "created_at": "2018-02-09 20:26:20", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "303490597": {"text": "# Summary\r\nI came to this while reading `Hash` documentation.\r\n\r\nBoth methods `Hash#length` and `Hash#size` share the same source code in Ruby, but they also share the same documentation. Now when you look at the documentation of `Hash#size` you only see examples for `Hash#length`, which is confusing.\r\n\r\nThis patch includes `Hash#size` in the examples and also remarks that both methods are equivalent to each other.\r\n\r\nMany thanks.", "labels": [], "number": 1833, "updated_at": "2018-03-14 18:08:50", "user": 671550, "closed_at": null, "id": 303490597, "title": "[Docs] Include Hash#size in the examples", "url": "https://api.github.com/repos/ruby/ruby/issues/1833", "created_at": "2018-03-08 14:05:17", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "153778913": {"text": "- `_filbuf`, `_flsbuf`, `enough_to_get()`,  `enough_to_put()` are unused since c15a74f3d0b31133c01a64334c6a660ad70fb442 / r50381\n- including `<stdio.h>` is unnecessary as `printf()`, etc. are not used\n", "labels": [], "number": 1347, "updated_at": "2018-02-23 03:07:11", "user": 212792, "closed_at": null, "id": 153778913, "title": "remove unnecessary preprocessor directives (Windows)", "url": "https://api.github.com/repos/ruby/ruby/issues/1347", "created_at": "2016-05-09 13:42:12", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "217814246": {"text": "I found an issue [Date#rfc2822 and Time#rfc2822 don't return the same format](https://bugs.ruby-lang.org/issues/13101) .\r\n\r\nI think  it is more natural that outputs of `rfc2822` methods are same in `Time`, `Date`, `DateTime`.\r\n\r\nI used following sample code,\r\n\r\n```ruby\r\nrequire 'time'\r\n\r\ntime = Time.new(2017, 4, 7, 15, 23, 32)\r\ndate = Date.new(2017, 4, 7)\r\ndatetime = DateTime.new(2017, 4, 7, 15, 23, 32)\r\n\r\nputs time.rfc2822\r\nputs date.rfc2822\r\nputs time.utc.rfc2822\r\nputs datetime.rfc2822\r\n```\r\n\r\nBefore output is,\r\n\r\n```\r\n> make runruby\r\n./miniruby -I../ruby/lib -I. -I.ext/common  ../ruby/tool/runruby.rb --extout=.ext  -- --disable-gems ../ruby/test.rb\r\nFri, 07 Apr 2017 15:23:32 +0900\r\nFri, 7 Apr 2017 00:00:00 +0000\r\nFri, 07 Apr 2017 06:23:32 -0000\r\nFri, 7 Apr 2017 15:23:32 +0000\r\n```\r\n\r\nAfter this patch is applied,\r\n\r\n```\r\n> make runruby\r\n./miniruby -I../ruby/lib -I. -I.ext/common  ../ruby/tool/runruby.rb --extout=.ext  -- --disable-gems ../ruby/test.rb\r\nFri, 7 Apr 2017 15:23:32 +0900\r\nFri, 7 Apr 2017 00:00:00 +0000\r\nFri, 7 Apr 2017 06:23:32 +0000\r\nFri, 7 Apr 2017 15:23:32 +0000\r\n```", "labels": [], "number": 1566, "updated_at": "2018-02-23 03:07:33", "user": 1119006, "closed_at": null, "id": 217814246, "title": "Match the behavior of rfc2822 methods", "url": "https://api.github.com/repos/ruby/ruby/issues/1566", "created_at": "2017-03-29 09:20:06", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "239545577": {"text": "As far as I can tell, this is not true:\r\n\r\n```\r\n[14] pry(main)> require 'delegate'                                                                                                                                                           \r\n=> false                                       \r\n[15] pry(main)> names = SimpleDelegator.new([1,2,3])                                          \r\n=> [1, 2, 3]                                   \r\n[16] pry(main)> names.first                    \r\n=> 1                                           \r\n[17] pry(main)> class C                        \r\n[17] pry(main)*   def foo                      \r\n[17] pry(main)*     :foo                       \r\n[17] pry(main)*   end                          \r\n[17] pry(main)* end                            \r\n=> :foo                                        \r\n[18] pry(main)> names.__setobj__(C.new)        \r\n=> #<C:0x00000004a97b18>                       \r\n[19] pry(main)> names.foo                      \r\n=> :foo                                        \r\n[20] pry(main)> names.first                    \r\nNoMethodError: undefined method `first' for #<C:0x00000004a97b18>                             \r\nfrom /home/tim/.rvm/rubies/ruby-2.3.0/lib/ruby/2.3.0/delegate.rb:87:in `method_missing'       \r\n[21] pry(main)>                                \r\n```", "labels": [], "number": 1662, "updated_at": "2018-02-23 03:07:37", "user": 3360080, "closed_at": null, "id": 239545577, "title": "Updated documentation", "url": "https://api.github.com/repos/ruby/ruby/issues/1662", "created_at": "2017-06-29 16:52:21", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "286242031": {"text": "\u2026 unless GCC is broken. \r\n\r\nI'll merge this once https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83696 is fixed.", "labels": [], "number": 1787, "updated_at": "2018-02-23 03:07:43", "user": 15377, "closed_at": null, "id": 286242031, "title": "Use -Wimplicit-fallthrough", "url": "https://api.github.com/repos/ruby/ruby/issues/1787", "created_at": "2018-01-05 09:58:14", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/355658181", "text": "* Wait at least it works on an implementation.\r\n* regparse.c has another upstream and it's periodically overwritten by upstream's one; the change can be merged in upstream\r\n* Apple clang supports -Wimplicit-fallthrough but doesn't work too? I couldn't see warnings...", "created_at": "2018-01-05 20:32:52", "user": 13423, "id": 355658181}], "assignees": [], "state": "open", "is-pull-request": true}, "169495803": {"text": "Provide a value to use in the event a field does not exist in your OpenStruct.\n\n``` ruby\nrequire 'ostruct' \n\nperson = OpenStruct.new('name' => 'John Smith', 'age' => 70)\n\nperson.delete_field('number') { 8675_309 } \n# => 8675309\n```\n", "labels": [], "number": 1409, "updated_at": "2018-02-23 03:07:14", "user": 5303827, "closed_at": null, "id": 169495803, "title": "Fallback value to OpenStruct delete_field", "url": "https://api.github.com/repos/ruby/ruby/issues/1409", "created_at": "2016-08-04 23:18:04", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237717141", "text": "I'm not against it, but I'm wondering if there's a particular use case (compared to `delete_field('foo') || value`)?\n", "created_at": "2016-08-04 23:34:45", "user": 33770, "id": 237717141}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237723140", "text": "With a bit more thought, given the nature of `OpenStruct`, I'm not sure that it's a good idea to make a difference between a member being defined and `nil` and one not being defined. In particular, there is no method `fetch` on `OpenStruct`, so I really wonder why `delete_field` would give access to that distinction.\n", "created_at": "2016-08-05 00:14:39", "user": 33770, "id": 237723140}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237725369", "text": "`delete_field('foo') || value` won't work. The current handling of a missing field is to rescue NameError and then re-raise NameError with a custom message. To recover you would also have to rescue. This, seems to me, provides a cleaner solution, if desired.\n", "created_at": "2016-08-05 00:30:45", "user": 5303827, "id": 237725369}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237756490", "text": "Oh, right, my bad. So I guess the equivalent would be\n\n```\nresult = person['number'] ||= 8675_309\nperson.delete_field 'number'\n```\n\nStill, the question remains, what is the use case?\n", "created_at": "2016-08-05 05:09:10", "user": 33770, "id": 237756490}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237922009", "text": "I currently use it in conjunction with `optparse`.  \n\nOptionParser does not have a mechanism for required parameter.\n\n``` ruby\nopts.on(\"-r\", \"--required\", \"This is required with no way to enforce it\") { |o| options.required = o }\n```\n\nSo, what I might currently have to do is this:\n\n``` ruby\nbegin \n  required = options.delete_field(:required)\nrescue NameError \n  raise MyCustomErrorClass, \"You failed to supply required information\"\nend \n```\n\nSince the `NameError` has already been rescued in the `delete_field` method, by supplying a block I can skip rescuing OpenStructs customized NameError and just raise my own. \n\n``` ruby\nrequired = options.delete_field(:required) do \n  raise MyCustomErrorClass, \"You failed to supply required information\"\nend\n```\n\nAlso, if there is no field set for some information that you can supply a basic value for, this:\n\n``` ruby\nfoo = options.delete_field(:foo) { 'some foo value' }\n```\n\nis much more convenient than this:\n\n```\nfoo = if options.respond_to?(:foo) \n            options.delete_field(:foo)\n          else\n            'some foo value'\n          end \n```\n\nor \n\n``` ruby\nfoo = options.foo ||= 'some foo value' \noptions.delete_field(:foo)\n```\n\nI should point out that if a field is set, this change will not affect it, even if the value for the field is nil. \n\n``` ruby\nperson = OpenStruct.new('name' => 'John Smith', 'age' => 70, 'address' => nil)\n\naddress = person.delete_field(:address) { '1600 Pennsylvania Ave' }\n# => nil \n```\n\nSo it is not equivalent to the example above,  `nil` might be an acceptable result.\n\n``` ruby\naddress = person['address'] ||= '1600 Pennsylvania Ave'\n# => '1600 Pennsylvania Ave' \n```\n\nObviously there are already ways to deal with the situations I am presenting, but, I feel, with this change it provides a simpler, more efficient means to achieve that result with no negative impact.\n", "created_at": "2016-08-05 18:09:25", "user": 5303827, "id": 237922009}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237933179", "text": "Thanks for the examples. Why do you need to call `delete_field`? The first example could simply be\n\n```\noptions[:required] ||  raise MyCustomErrorClass, \"You failed to supply required information\"\n```\n\nAnd why is options an `OpenStruct` instead of a `Hash`?\n", "created_at": "2016-08-05 18:52:29", "user": 33770, "id": 237933179}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237954213", "text": "I'm using an `OpenStruct` instead of a `Hash` because I prefer the dot notation. \n\n``` ruby\noptions.thing   = true \noptions[:thing] = true\n```\n\nI need to use `delete_field` because if the information does exist it needs to be removed from the structure. Eventually it will be turned into a `Hash` and shoved into a database. \n\n``` ruby\nrequired = options.delete_field(:required) do \n  raise MyCustomErrorClass, \"You failed to supply required information\"\nend\n\nthings = options.delete_field(:thing) { 'value' } \n\noptions.table_data ||= \"some table data\"\n\n# delete more fields/manipulate data...\n\nmy_database_thing = MyDatabaseThing.create(options.to_h)\n```\n\nI initially expected `OpenStruct` to behave more like a `Hash`. \n\n``` ruby\nhash_options = Hash.new\n\nrequired = hash_options.delete(:required) do \n  raise MyCustomErrorClass, \"You failed to supply required information\"\nend\n# => MyCustomErrorClass: You failed to supply required information\n\n# OpenStruct current implementation\nrequired = options.delete_field(:required) do \n  raise MyCustomErrorClass, \"You failed to supply required information\"\nend\n# => NameError: no field `required' in #<OpenStruct>\n\n\nfoo = hash_options.delete(:foo) { 'some foo value' }\n# => \"some foo value\"\n```\n\nArrays behave in this same fashion. \n\n``` ruby\na = Array.new \n\nfoo = a.delete(:foo) { 'some foo value' }\n# => \"some foo value\"\n\nfoo = a.delete(:foo) do |value|\n  raise MyCustomErrorClass, \"no such value #{value} in array\"\nend \n# => MyCustomErrorClass: no such value foo in array\n```\n\nThus, the proposed change brings `OpenStruct` more inline with what is common for other basic Ruby data structures. Taking it a step further and not raising a `NameError` and returning `nil` would make it even more uniform.\n", "created_at": "2016-08-05 20:25:47", "user": 5303827, "id": 237954213}], "assignees": [33770, 33770], "state": "open", "is-pull-request": true}, "217766654": {"text": "Currently, C extensions cannot use fstrings. I'd like to use\r\nrb_fstring_cstr instead of rb_str_new_cstr for static strings in C\r\nextensions.", "labels": [], "number": 1559, "updated_at": "2018-02-23 03:07:32", "user": 69755, "closed_at": null, "id": 217766654, "title": "Expose rb_fstring and its family to C extensions", "url": "https://api.github.com/repos/ruby/ruby/issues/1559", "created_at": "2017-03-29 05:12:52", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/289995022", "text": "I've created a ticket for this PR.\r\nhttps://bugs.ruby-lang.org/issues/13381", "created_at": "2017-03-29 06:25:07", "user": 69755, "id": 289995022}], "assignees": [], "state": "open", "is-pull-request": true}, "171947267": {"text": "\u2026ullptr.\n\nDetails: http://www.viva64.com/en/b/0414/#ID0EQ1CI\n", "labels": [], "number": 1414, "updated_at": "2018-02-23 03:07:15", "user": 112516, "closed_at": null, "id": 171947267, "title": "V595 The 'bind' pointer was utilized before it was verified against n\u2026", "url": "https://api.github.com/repos/ruby/ruby/issues/1414", "created_at": "2016-08-18 16:42:42", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "274466061": {"text": "I introduce a `difference` method equivalent to the `-` operator, but which accept more than array as argument. This improved readability, and it is also coherent with the `+` operator, which has a similar `concat` method. The method doesn't modify the original object and return a new object instead. I plan to introduce a `difference!` method as well. \ud83d\ude04 \r\n\r\nTests and documentation are included. :bowtie: I also corrected a small mistake in the `Array#-` documentation and link the new method from there. \r\n\r\nIt solves partially https://bugs.ruby-lang.org/issues/14097", "labels": [], "number": 1758, "updated_at": "2018-02-23 03:07:41", "user": 16052290, "closed_at": null, "id": 274466061, "title": " Add difference method to Array", "url": "https://api.github.com/repos/ruby/ruby/issues/1758", "created_at": "2017-11-16 10:29:34", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/344905474", "text": "I am not sure if `difference` is the best name. `a`.diference `b` is what for sets is commonly called in logic _relative complement_ or _theoretic difference_ of a in b, which is defined as ![equation](http://latex.codecogs.com/gif.latex?b%20%5Ccap%20a%5E%5Ccomplement). And this is usually written with the `\\` operator.\r\n\r\nIn the Set class we already called this `-` and `difference`, which it is ok but not really accurate because of the previous explanation, but probably not worthwhile to change it.\r\n\r\nAnd all this is for Set, this concept is not usually define in Arrays. I decided to use the same name to keep the consistence with the Set class and because it was also written like that in the Array code. But I was thinking that maybe `exclude` could be more explicit. `minus` could be another option, but it has the same problem as `-`, which in Sets is ok (inaccurate thought), but in an Array I would have expected to be the difference of every component of two arrays of the same length.\r\n\r\nIntroducing alias doesn't work in my opinion, I think it is better to think what the best option is than having many options for the same.\r\n\r\nAny thoughts on this or do just I keep it as `difference`?", "created_at": "2017-11-16 12:13:39", "user": 16052290, "id": 344905474}], "assignees": [], "state": "open", "is-pull-request": true}, "273448216": {"text": "The adverb usually refers to what typically or normally happens and because of that it should be used in present tense and not in future. :bowtie: \r\n\r\nReference:\r\nhttps://dictionary.cambridge.org/es/gramatica/gramatica-britanica/usually", "labels": [], "number": 1750, "updated_at": "2018-02-23 03:07:40", "user": 16052290, "closed_at": null, "id": 273448216, "title": "Correct grammar mistake in README", "url": "https://api.github.com/repos/ruby/ruby/issues/1750", "created_at": "2017-11-13 14:28:35", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "267359519": {"text": "I often feel that C API documents are lacked in C source codes, especially for static functions.\r\n\r\nWith https://bugs.ruby-lang.org/issues/904, make install-capi target was introduced to generate c api documents using Doxygen.\r\nHowever, I feel that it is not utilized among C Ruby developers.\r\n\r\nI propose to turn EXTRACT_STATIC = YES flag of Doxygen to YES, and write document comments for static functions as much as possible.\r\n\r\nFor https://bugs.ruby-lang.org/issues/14037", "labels": [], "number": 1722, "updated_at": "2018-02-23 03:07:39", "user": 2290461, "closed_at": null, "id": 267359519, "title": "Doxyfile: EXTRACT_STATIC: YES", "url": "https://api.github.com/repos/ruby/ruby/issues/1722", "created_at": "2017-10-21 07:46:55", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "136920866": {"text": "# Rationale\n\nTo me, integer-without-limit is one of the greatest features of Ruby.  I am currently working on my own implementation of arbitrary precision number system (https://github.com/dankogai/swift-pons) and ruby has been my sensei.\n\nThat is why I am disappointed to find `prime.rb` is pretty darn impractical, even for such \"small\" numbers below the 64-bit boundary.  Consider this:\n\n``` shell\nruby -rprime -e 'p (2**61-1).prime?' # hello, anybody home?\n```\n\nM61 is well below an ordinary, fixed, 64-bit integer can hold.\n\nThis patch makes `prime.rb` a little more practical by:\n- making `.prime?` base upon Miller-Rabin primarity test\n  - but unlike other patch proposals (like https://bugs.ruby-lang.org/issues/11578 ), this one is deterministic up to 318665857834031151167461, well over `uint64_t` max.\n- adding `.next_prime` and `.prev_prime` which returns the (next|previous) prime.\n- adding `Prime::NextPrimeGenerator` which makes use of `.next_prime`.\n# vs. OpenSSL::BN\n\nLike current `prime.rb`, this patch is by no means to replace `OpenSSL::BN.prime?`.  For very large numbers `OpenSSL::BN` is still faster.  But for numbers below 32-bit limit this patch is faster.  And for numbers between 32-bit limit and 64-bit limit, its performance is okay.\n\n``` ruby\n# coding: utf-8\nrequire 'benchmark'\nrequire 'prime'\nrequire 'openssl'\n\ncount = 10000\n\n[\n  2147483647,                # int32 max == M31\n  1<<61 - 1,                 # M61\n  2147483647*2147483629,     # M31 * M31.prev_prime\n  18446744073709551427,      # the largest prime uint64_t can handle\n  318665857834031151167461,  # A014233_11\n  # found at:\n  # https://rosettacode.org/wiki/Miller\u2013Rabin_primality_test\n  4547337172376300111955330758342147474062293202868155909489, # prime\n  4547337172376300111955330758342147474062293202868155909393  # composite\n].each do |n|\n  primerbsays   = n.prime?\n  opensslbnsays = OpenSSL::BN.new(n.to_s).prime?\n  puts \"#{n}.prime? => #{primerbsays}\"\n  puts \"OpenSSL::BN.new(#{n}.to_s).prime? => #{opensslbnsays}\"\n  puts \"Do they agree? #{primerbsays == opensslbnsays}\"\n  Benchmark.bm do |x|\n    x.report(\"OpenSSL::BN\") {\n      count.times { OpenSSL::BN.new(n.to_s).prime? }\n    }\n    x.report(\"prime.rb\") {\n      count.times { n.prime? }\n    }\n  end\nend\n```\n\n```\n2147483647.prime? => true\nOpenSSL::BN.new(2147483647.to_s).prime? => true\nDo they agree? true\n       user     system      total        real\nOpenSSL::BN  1.190000   0.010000   1.200000 (  1.216361)\nprime.rb  0.180000   0.000000   0.180000 (  0.190299)\n1152921504606846976.prime? => false\nOpenSSL::BN.new(1152921504606846976.to_s).prime? => false\nDo they agree? true\n       user     system      total        real\nOpenSSL::BN  0.010000   0.000000   0.010000 (  0.009166)\nprime.rb  0.000000   0.000000   0.000000 (  0.000847)\n4611685975477714963.prime? => false\nOpenSSL::BN.new(4611685975477714963.to_s).prime? => false\nDo they agree? true\n       user     system      total        real\nOpenSSL::BN  0.120000   0.010000   0.130000 (  0.123623)\nprime.rb  0.300000   0.000000   0.300000 (  0.308675)\n18446744073709551427.prime? => true\nOpenSSL::BN.new(18446744073709551427.to_s).prime? => true\nDo they agree? true\n       user     system      total        real\nOpenSSL::BN  1.980000   0.020000   2.000000 (  2.023935)\nprime.rb  4.330000   0.020000   4.350000 (  4.390414)\n318665857834031151167461.prime? => false\nOpenSSL::BN.new(318665857834031151167461.to_s).prime? => false\nDo they agree? true\n       user     system      total        real\nOpenSSL::BN  0.100000   0.010000   0.110000 (  0.105193)\nprime.rb  4.320000   0.010000   4.330000 (  4.346966)\n4547337172376300111955330758342147474062293202868155909489.prime? => true\nOpenSSL::BN.new(4547337172376300111955330758342147474062293202868155909489.to_s).prime? => true\nDo they agree? true\n       user     system      total        real\nOpenSSL::BN  1.790000   0.000000   1.790000 (  1.799558)\nprime.rb 27.270000   0.260000  27.530000 ( 28.073170)\n4547337172376300111955330758342147474062293202868155909393.prime? => false\nOpenSSL::BN.new(4547337172376300111955330758342147474062293202868155909393.to_s).prime? => false\nDo they agree? true\n       user     system      total        real\nOpenSSL::BN  0.170000   0.000000   0.170000 (  0.168822)\nprime.rb  2.020000   0.010000   2.030000 (  2.054712)\n```\n# Conclusion\n\nIMHO the gap between `prime.rb` and `OpenSSL::BN` is now unacceptably too large.  It was acceptable when native integers were only 32-bit wide.  But it is 2016 and even your phone may be using 64-bit int.\n`.prime?` should return instantly at least within 64-bit range.\n\nDan the Amateur Rubyist\n", "labels": [], "number": 1272, "updated_at": "2018-02-23 03:07:09", "user": 68812, "closed_at": null, "id": 136920866, "title": "next_prime for lib/prime.rb", "url": "https://api.github.com/repos/ruby/ruby/issues/1272", "created_at": "2016-02-27 13:44:28", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237008214", "text": "When I was in bed I also realized I could do `self == 41 || miller_rabin_test(41)`,\nso yeh, good catch.\n\nActually, your suggestions for `prime1?` undoes the reasons for doing it that way.\n\nFirst, my initial modifications of `miller_rabin_test` and `prime?` was to just\nimprove the coding implementation of the pull requester's design. I followed what\nhe proposed but just coded the same functionality faster and more efficiently.\n\nWith `prime1?` I wanted to redesign the implementation to a more `functional programming`\n(FP) style, with the deliberate goal to allow it to be performed efficiently in parallel.\nThe ultimate purpose for doing this is to create a design that can perform optimally.\n\nSo I separated out the distinct functional steps so they can be performed independently.\nFinding the appropriate range for the input number is a separate process.\nThen finding the witnesses for the range is a separate process.\nFinally, performing the `miller-rabin` tests with the proper witnesses is a separate process.\n\nThe goal of `prime1?` was to get to `prime2?`. The `miller-rabin` are independent tests,\nand don't share any memory, so they can inherently be done in parallel. So the only change\nto `prime1?` to allow the `miller-rabin` tests be done in parallel is to use the\n`Parallel.each(witnesses)..` method from the `parallel` gem.  The timing results tell all.\nWhen CRuby (3.0 ?) supports parallelization, this can be replaced by its native method(s).\n\nAh, but we can do better.\n\nThe original design has some unnecessary dependencies we can eliminate to make the code \neasier to update and mathematically modify.\n\nThe design uses a specific set of ranges/witnesses to provide deterministic results over those \nranges. See such as https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test for the\nmathematical details.\n\nThe way the Prime::A014233 hash is constructed, each larger range is dependent on all the\nsmaller ranges keys to determine its witnesses.  This forces us to find (code) a way to\ndetermine the correct set of witnesses for each range. For this particular design, it's\npretty straight forward to do this. But what would have to happen if the mathemeticians\nfind a better set of ranges/witnesses that don't follow this particular scheme?\n\nThe fix is to create the hash so that the keys are the ranges whose values are arrays of\nall their witnesses. Now, the ranges are independent, and new ranges can be added/modified\nwithout worry of affecting another range. `Prime::A014233NEW` below shows this. Now, finding \nthe appropriate range automatically provides the appropriate witnesses.\n\nIn the code for `prime3?` one line now finds the appropriate witnesses for a range.\n`wits = Prime::A014233NEW.sort.detect {|range, wits| range > self}`.\n\nLet's break this down.\n\n```\nwits = Prime::A014233NEW.sort.              # make sure for old/new Rubys' the keys are sorted\n       detect {|range, wits| range > self}` # find first [range, [wits]] pair where range > self\n                                            # if no range > self then wits =  nil\n```\n\nThen we do `wits && wits[1] || witnesses` to determine the array of witnesses for testing with.\nIf `wits` is `nil` then `wits && wits` is `false` and we use the default `witnesses` array.\nOtherwise `wits && wits[1]` returns `wits[1]` to be the witnesses array for the identified range.\n\nIn `prime3?` every line is an independent functional entity, and new `range => [wits]` pairs can be\nadded to Prime::A014233NEW independently (without regard to their position in the hash).\n\nBut I can even make `prime3?` a little bit more (mathematically) efficient, as shown in `prime4?`.\n\nSince I'm creating an array of consecutive `witnesses` primes, I might as well use it to check\nfor small primes, instead of creating a smaller array of small primes.  And I also might as\nwell use this modulus for these Prime Generator primes as my `non-primality` test.\n\nSo `m = witnesses.reduce(:*)` is 304,250,263,527,210,\nand the `non-primality` test `m.gcd(self) == 1` will eliminate 85.5% of all integers\nfrom consideration to being prime, instead of the 77% eliminated by `210.gcd(self) == 1`. \n(see Primes-Utils Handbook for details).\n\nThus, I think `prime4?` represents the most mathematically efficient/optimally performant \ndesign/code for doing this.\n\n```\nclass Integer\n  ...\n  ...\n\n  def prime3?    # perform miller-rabin tests in parallel\n    return true if [2, 3, 5, 7].include? self\n    return false unless self > 1 and 210.gcd(self) == 1\n    witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    wits = Prime::A014233NEW.sort.detect {|range, wits| range > self} # [range, [wits]] or nil\n    Parallel.each(wits && wits[1] || witnesses) { |p| return false unless miller_rabin_test(p) }\n    true\n  end\n\n  def prime4?    # perform miller-rabin tests in parallel\n    witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    return true if witnesses.include? self\n    m = witnesses.reduce(:*)                           # modulus for P41 Prime Generator\n    return false unless self > 1 and m.gcd(self) == 1  # non-primality test for P41\n    wits = Prime::A014233NEW.sort.detect {|range, wits| range > self} # [range, [wit_prms]] or nil\n    Parallel.each(wits && wits[1] || witnesses) { |p| return false unless miller_rabin_test(p) }\n    true\n  end\nend\n\nclass Prime\n  # https://oeis.org/A014233\n  #\n  # Smallest odd number for which Miller-Rabin primality test\n  # on bases <= n-th prime does not reveal compositeness.\n  #\n  A014233 = {\n    2  => 2_047,\n    3  => 1_373_653,\n    5  => 25_326_001,\n    7  => 3_215_031_751,\n    11 => 2_152_302_898_747,\n    13 => 3_474_749_660_383,\n    17 => 341_550_071_728_321,\n    19 => 341_550_071_728_321,\n    23 => 3_825_123_056_546_413_051,\n    29 => 3_825_123_056_546_413_051,\n    31 => 3_825_123_056_546_413_051,\n    37 => 318_665_857_834_031_151_167_461\n  }\n\n  A014233NEW = {\n    2_047 => [2],\n    1_373_653 => [2, 3],\n    25_326_001 => [2, 3, 5],\n    3_215_031_751 => [2, 3, 5, 7],\n    2_152_302_898_747 => [2, 3, 5, 7, 11],\n    3_474_749_660_383 => [2, 3, 5, 7, 11, 13],\n    341_550_071_728_321 => [2, 3, 5, 7, 11, 13, 17],\n    3_825_123_056_546_413_051 => [2, 3, 5, 7, 11, 13, 17, 19, 23],\n    318_665_857_834_031_151_167_461 => [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n  }\nend\n```\n", "created_at": "2016-08-02 19:02:01", "user": 69856, "id": 237008214}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/237090982", "text": "I am glad that I could help in minor details and eventually motivated this discussion.\nAnd you really flipped the key values, I thought this was just a crazy idea but wrote anyway.\nNow I understand that your goal is to fully parallelize the process.\nI would still use `sort!` instead of `sort` to avoid GC calls, but that would make no difference in a small benchmark.\nIt seems like you achieved the best solution, have you seen the tests?\n5 tests were failing in the original request, 4 of them because 41 was missing and 1 because of timeout.\n", "created_at": "2016-08-03 00:16:54", "user": 11094484, "id": 237090982}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/238981308", "text": "Been busy, couldn't respond immediately.\n\nRegarding test passing, all my versions of `primex?` pass the tests I run to\nverify their accuracy. As you noted, the original pull request code gave a\nfalse negative to 41 because of the architecural structure, as I elaborated on.\n\nBut the crux of the pull request is to improve the performance of the `prime.rb`\nstd lib methods.  That goal, and also to provide more enhanced methods, is why\nI create the `primes-utils` gem.\n\nFortunately, the current method for `prime?` in `prime.rb` uses the math from\n`primes-utils` (see https://www.scribd.com/doc/266461408/Primes-Utils-Handbook)\nmaking it significatntly faster than its previous implementation, i.e. before its\ninclusion in Ruby 2.3.0 (released Christmas 2015, 2015/12/25).\n\nHowever, this version, which uses the P3 Strictly-Prime Prime Generator (SP PG),\ncan be made much faster by using the next higher SP PG, i.e. P5, as with `primep5?`.\nThis allows it to be used with bigger numbers with much better performance.\n\n```\nclass Integer\n\n  def prime?     # version now used in prime.rb since MRI 2.3.0\n    return self >= 2 if self <= 3\n    return false if self % 2 == 0 or self % 3 == 0\n    # return false unless 6.gcd(self) == 1              # simplification\n    (5..(self**0.5).floor).step(6).each do |i|\n      if self % i == 0 || self % (i + 2) == 0\n        return false\n      end\n    end\n    true\n  end\n\n  def primep5?   # Uses P5 Strictly-Prime PG\n    return false unless self > 1 and 30.gcd(self) == 1 or [2,3,5].include? self\n    (7..Math.sqrt(self).to_i).step(30) do |p|\n      return false if \n        self%(p)    == 0 or self%(p+4)  == 0 or self%(p+6)  == 0 or self%(p+10) == 0 or\n        self%(p+12) == 0 or self%(p+16) == 0 or self%(p+22) == 0 or self%(p+24) == 0\n    end\n    true\n  end\n\nend\n```\n\nThe P7 SP PG is even faster (for increasing numbers) but the code is not as compact.\nIn fact, I just submitted using `primep5?` to the Ruby issues tracker as an easy/simple \nimprovement to `prime?` in `prime.rb`. https://bugs.ruby-lang.org/issues/12665\n\nBelow are some timing comparisions for 3 progressively larger primes for 2.3.1.\nSystem: System76 3.5GHz I7 cpu laptop, Linux 64-bit OS\n\n```\nn1 =   100_000_000_000_000_003\nn2 =   200_000_000_000_000_003\nn3 = 1_000_000_000_000_000_003\n\n               n1         n2         n3\nprime?        4.1        5.7        12.9\nprimep5?      2.5        3.6         7.9\n\ndef tm; s = Time.now; yield; Time.now - s end\n\nirb(main):028:0> n = 100_000_000_000_000_003; tm{ n.prime? }\n=> 4.127392644\nirb(main):029:0> n = 100_000_000_000_000_003; tm{ n.primep5? }\n=> 2.539485672\nirb(main):030:0> n = 200_000_000_000_000_003; tm{ n.prime? }\n=> 5.721895509\nirb(main):031:0> n = 200_000_000_000_000_003; tm{ n.primep5? }\n=> 3.56925564\nirb(main):032:0> n = 1_000_000_000_000_000_003; tm{ n.prime? }\n=> 12.940908142\nirb(main):033:0> n = 1_000_000_000_000_000_003; tm{ n.primep5? }\n=> 7.920408959\n```\n\nSo, just making this minor change to `prime?` creates major performance benefits,\nwhile using a mathematical technique that is totally deterministic.\n\nThis pull request uses the Miller-Rabin (MR) test for `prime?`, with the minimum set of\nprime witnesses to supposedly make the MR tests deterministic over specific number ranges.\nHowever, for 'small' numbers, I see the code producing random false negatives results.\n\nRepeatedly run this test below (for small numbers) with `prime?` using MR, and then with `prime?`\nfrom `prime.rb`. The answer to `s.size` should be 78498.\n\n```\n2.3.1 :029 > s = []; 1000000.times{|i| s << i if i.prime?}\n => 1000000 \n2.3.1 :030 > s.size    # should be 78498\n```\n\nFrom my testing, using SP PGs are faster than MR for 'small' numbers, and 100% accurate,\nwhile MR shines for larger numbers (for speed).  In `primes-utils` I provide and use a \nrandomized MR version that is probablistic. I can incorporate the code here for MR to make \nit determinsitic over its (larger) deterministic ranges. I think the key for the devs to\nconsider is first accuracy, and then speed. Getting wrong results fast is not the goal.\n\nThis suggests that if you want the best of both worlds (100% accuracy and speed) in one\nmethod combining the use of PGs and MR may be the way to go.  Something to consider.\n\nBelow are additional simplifications to the methods `next_prime` and `prev_prime` in\nthe pull request code.\n\n```\nclass Integer\n\ndef next_prime                           def next_prime\n  return 2 if self < 2                     return 2 if self < 2\n  n = self\n  n += if n & 1 == 0 then 1 else 2 end     n = self + 1 | 1          # 1st odd number > self\n  while !n.prime?                          n += 2 until n.prime?     # do until n is prime\n    n += 2\n  end\n  return n                                 n\nend                                      end\n\ndef prev_prime                           def prev_prime\n  return nil if self <= 2                  return nil if self <= 2\n  return   2 if self == 3                  return   2 if self == 3\n  n = self\n  n -= if n & 1 == 0 then 1 else 2 end     n = self - 2 | 1          # 1st odd number < self\n  while !n.prime?                          n -= 2 until n.prime?     # do until n is prime\n    n -= 2\n  end\n  return n                                 n\nend                                      end\n```\n\nHere are all my modifications to the pull requester's code.\nThe code is now much shorter, more readable, and (hopefully) should pass every test.\n\n```\nrequire 'openssl'\n\nclass Integer\n\n  # Returns true if +self+ passes Miller-Rabin Test on +b+\n  def miller_rabin_test(b)             # b is a witness to test with\n    return self >= 2 if self <= 3 \n    return false unless 6.gcd(self) == 1\n    n = d = self - 1\n    d >>= 1 while d.even?\n    y = b.to_bn.mod_exp(d, self)       # y = (b**d) mod self\n    while d != n && y != n && y != 1\n      y = y.to_bn.mod_exp(2, self)     # y = (y**2) mod self\n      d <<= 1\n    end\n    y == n || d.odd?\n  end\n\n  # Returns true if +self+ is a prime number, else returns false.\n  def prime?\n    witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    return true if witnesses.include? self\n    return false unless self > 1 and witnesses.reduce(:*).gcd(self) == 1\n    wits = Prime::A014233NEW.sort.detect {|range, wits| range > self} # [range, [wit_prms]] or nil\n    witnesses = wits && wits[1] || witnesses\n    witnesses.each { |p| return false unless miller_rabin_test(p) }\n    true\n  end\n\n  # Returns the smallest prime number which is greater than +self+\n  def next_prime\n    return 2 if self < 2\n    n = self + 1 | 1          # first odd number > self\n    n += 2 until n.prime?     # find first prime > self\n    n\n  end\n\n  # Returns the largest prime number which is smaller than +self+\n  # or +nil+ if +self+ <= 2\n  def prev_prime\n    return nil if self <= 2\n    return   2 if self == 3\n    n = self - 2 | 1          # first odd number < self\n    n -= 2 until n.prime?     # find first prime < self\n    n\n  end\n\nend\n\nclass Prime\n\n  # https://oeis.org/A014233\n  #\n  # Smallest odd number for which Miller-Rabin primality test\n  # on bases <= n-th prime does not reveal compositeness.\n  #\n  A014233NEW = {\n    2_047 => [2],\n    1_373_653 => [2, 3],\n    25_326_001 => [2, 3, 5],\n    3_215_031_751 => [2, 3, 5, 7],\n    2_152_302_898_747 => [2, 3, 5, 7, 11],\n    3_474_749_660_383 => [2, 3, 5, 7, 11, 13],\n    341_550_071_728_321 => [2, 3, 5, 7, 11, 13, 17],\n    3_825_123_056_546_413_051 => [2, 3, 5, 7, 11, 13, 17, 19, 23],\n    318_665_857_834_031_151_167_461 => [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n  }\nend\n```\n\nNow you can do, very fast, and for very large numbers, things like:\n\n```\n> 11111111111118349843942143.prime?     => false\n> 11111111111118349843942143.next_prime => 11111111111118349843942147\n> 11111111111118349843942143.prev_prime => 11111111111118349843942109\n> (2**64).prev_prime   => 18446744073709551557\n> (2**128).preve_prime => 340282366920938463463374607431768211297\n```\n\nThere are still code and performance improvements that can be made to the other \nmethods in `prime.rb`, especially `prime_division`, which I replaced with `factors`\nin `prime-utils`.  Actually, I would love to see the devs take everything from \n`primes-utils` and incorporate its techniques into the std lib, which would make \nRuby much more useful, flexible, and performant, for all things prime.\n", "created_at": "2016-08-10 19:43:41", "user": 69856, "id": 238981308}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/312269763", "text": "This page shows numbers up to 71.\r\nhttp://mathworld.wolfram.com/StrongPseudoprime.html\r\n\r\n\u03c820 meaning [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71 ] base numbers.\r\n\r\nPrime::A014233 can extend \r\n~~~\r\n  41 => 3_317_044_064_679_887_385_961_981,\r\n  43 => 6_003_094_289_670_105_800_312_596_501,\r\n  47 => 59_276_361_075_595_573_263_446_330_101,\r\n  53 => 564_132_928_021_909_221_014_087_501_701,\r\n  59 => 564_132_928_021_909_221_014_087_501_701,\r\n  61 => 1_543_267_864_443_420_616_877_677_640_751_301,\r\n  67 => 1_543_267_864_443_420_616_877_677_640_751_301,\r\n  71 => 10 ** 36,\r\n~~~\r\n", "created_at": "2017-06-30 13:40:00", "user": 1475814, "id": 312269763}], "assignees": [], "state": "open", "is-pull-request": true}, "243305764": {"text": "\u2026ring\r\n\r\nI think String#casecmp and String#casecmp? are similar methods.\r\nBut they have different performance on ASCII string.\r\n\r\nSeems that String#casecmp handles ASCII string only,\r\nhowever it is faster than String#casecmp?.\r\nBecause String#casecmp? duplicates object at `rb_str_downcase()` every time.\r\n\r\nThis patch will use the code of String#casecmp with ASCII string on String#casecmp?.\r\nBut, this patch will introduce a few penalties for UTF8 string in where detect ASCII/UTF8 string.\r\n\r\n```\r\nString#casecmp? ASCII -> 61.3 % up\r\nString#casecmp? UTF8  ->  1.3 % down\r\nSymbol#casecmp? ASCII -> 80.0 % up\r\nSymbol#casecmp? UTF8  ->  4.0 % down\r\n```\r\n\r\n### Before\r\n```\r\nCalculating -------------------------------------\r\n      String#casecmp      5.961M (\u00b1 3.8%) i/s -     29.838M in   5.017907s\r\nString#casecmp? ASCII\r\n                          3.530M (\u00b1 8.6%) i/s -     17.554M in   5.034848s\r\nString#casecmp? UTF8      1.252M (\u00b1 7.4%) i/s -      6.213M in   5.012168s\r\n      Symbol#casecmp      8.555M (\u00b1 2.4%) i/s -     42.822M in   5.009280s\r\nSymbol#casecmp? ASCII\r\n                          4.235M (\u00b1 9.7%) i/s -     20.824M in   5.001368s\r\nSymbol#casecmp? UTF8      1.329M (\u00b1 0.1%) i/s -      6.704M in   5.043725s\r\n```\r\n\r\n### After\r\n```\r\nCalculating -------------------------------------\r\n      String#casecmp      5.984M (\u00b1 6.4%) i/s -     29.829M in   5.020331s\r\nString#casecmp? ASCII\r\n                          5.658M (\u00b1 1.5%) i/s -     28.308M in   5.004547s\r\nString#casecmp? UTF8      1.215M (\u00b1 4.3%) i/s -      6.132M in   5.060292s\r\n      Symbol#casecmp      8.651M (\u00b1 0.9%) i/s -     43.313M in   5.007215s\r\nSymbol#casecmp? ASCII\r\n                          7.462M (\u00b1 0.5%) i/s -     37.489M in   5.023892s\r\nSymbol#casecmp? UTF8      1.275M (\u00b1 0.2%) i/s -      6.444M in   5.052743s\r\n```\r\n\r\n### Test code\r\n```ruby\r\nrequire 'benchmark/ips'\r\n\r\nBenchmark.ips do |x|\r\n  x.report \"String#casecmp\" do |loop|\r\n    loop.times { \"aBcDeF\".casecmp(\"abcdefg\") }\r\n  end\r\n  x.report \"String#casecmp? ASCII\" do |loop|\r\n    loop.times { \"aBcDeF\".casecmp?(\"abcdefg\") }\r\n  end\r\n  x.report \"String#casecmp? UTF8\" do |loop|\r\n    loop.times { \"\\u{e4 f6 fc}\".casecmp?(\"\\u{c4 d6 dc}\") }\r\n  end\r\n\r\n  x.report \"Symbol#casecmp\" do |loop|\r\n    loop.times { :aBcDeF.casecmp(:abcdefg) }\r\n  end\r\n  x.report \"Symbol#casecmp? ASCII\" do |loop|\r\n    loop.times { :aBcDeF.casecmp?(:abcdefg) }\r\n  end\r\n  x.report \"Symbol#casecmp? UTF8\" do |loop|\r\n    loop.times { :\"\\u{e4 f6 fc}\".casecmp?(:\"\\u{c4 d6 dc}\") }\r\n  end\r\nend\r\n```\r\n\r\nhttps://bugs.ruby-lang.org/issues/13750", "labels": ["Performance"], "number": 1668, "updated_at": "2018-02-23 03:07:37", "user": 199156, "closed_at": null, "id": 243305764, "title": "Improve String#casecmp? and Symbol#casecmp? performance with ASCII st\u2026", "url": "https://api.github.com/repos/ruby/ruby/issues/1668", "created_at": "2017-07-17 06:28:47", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "273368365": {"text": "Hi.\r\nI think `::` for call methods may cause confusion. In this pr `::` call notation changed to `.` dot call. \r\nMaybe it makes sense only for documentation.", "labels": [], "number": 1749, "updated_at": "2018-02-23 03:07:40", "user": 1192122, "closed_at": null, "id": 273368365, "title": "change call CGI methods from :: to .", "url": "https://api.github.com/repos/ruby/ruby/issues/1749", "created_at": "2017-11-13 09:52:58", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "273322298": {"text": "It is now possible to add just the subdomains for proxy bypass.\r\nIn a setting where the main domain needs to go through proxy while\r\nthe subdomains don't, it is now possible to just add the subdomains\r\nto the no_proxy list.\r\n\r\nThe assumption that both subdomains and the parent domain should\r\nbehave the same wrt no_proxy has been removed.\r\n\r\neg: Adding .example.com in no_proxy would allow example.com\r\nto go through the proxy.\r\n\r\n Addresses: https://bugs.ruby-lang.org/issues/14345", "labels": [], "number": 1748, "updated_at": "2018-03-21 01:59:52", "user": 1289830, "closed_at": null, "id": 273322298, "title": "URI::Generic: Respect no_proxy for both parent domain and subdomains", "url": "https://api.github.com/repos/ruby/ruby/issues/1748", "created_at": "2017-11-13 06:23:46", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/344822986", "text": "Do I need a reviewer here?\r\n", "created_at": "2017-11-16 05:49:47", "user": 1289830, "id": 344822986}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/345235190", "text": "Please submit a new issue to our \"official\" tracker: https://bugs.ruby-lang.org/\r\n\r\nWe didn't handle new feature on GitHub.", "created_at": "2017-11-17 12:48:07", "user": 12301, "id": 345235190}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/363530027", "text": "Hi, Any update on this?", "created_at": "2018-02-06 19:05:24", "user": 1289830, "id": 363530027}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/364338796", "text": "@hsbt ", "created_at": "2018-02-09 05:25:53", "user": 1289830, "id": 364338796}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/364341099", "text": "No update. I'm not maintainer of `URI` library.", "created_at": "2018-02-09 05:44:00", "user": 12301, "id": 364341099}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/374752483", "text": "@matz Could you suggest how we take this forward?", "created_at": "2018-03-20 20:52:47", "user": 1289830, "id": 374752483}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/374814816", "text": "@harsimranmaan Current `URI` maintainer is not active. So, I'm going to ask this feature request at next developer meeting. Please no rush and wait a few months.", "created_at": "2018-03-21 01:59:52", "user": 12301, "id": 374814816}], "assignees": [], "state": "open", "is-pull-request": true}, "173351229": {"text": "### Abstract\n\n![](https://cloud.githubusercontent.com/assets/15377/17991607/1c2a3024-6b7b-11e6-88cf-da2b0cfba503.png)\n\nImplemented a way to optimize ruby's executions and to revert them.  The strategy is restricted so that any VM states like program counter(s) would not be affected by the modifications.  This restriction makes deoptimize much lightweight.  Experiments show optimizations on this mechanism speeds up micro benchmarks, yet has no significant overheads for pitfall-ish activities, like eval.\n### Introduction\n\n<details>\n<summary>\n\nRuby is said to be slow[[1](https://www.google.co.jp/search?q=ruby%20is%20slow)].  While there can be arguments on this, experiments show that it is at least not the fastest language to execute[[2](http://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html)]. \u2026\n</summary>\n\n\n\nThe reason behind this is fingered as its GC being slow, or its GVL, or its dynamic nature.  But the author would like to point out the most important thing that Ruby lacks; it does not even try to optimize its execution.  We believe this is the root cause of the slowness we suffer.\n\nWe wrote \"try to\" above.  This is the essential concept of this pull request.  Why Ruby did not optimize so far was that its execution might be different on occasions.  For instance a `1 + 2` might not always be `3`, because the `+` can be redefined on-the-fly.  So the interpreter does not constant-fold the expression and looks for `Integer#+` every time.\n\nThis redefinition however, rarely happens.  Almost every time when `1 + 2` is evaluated, its value is arguably `3`.  Given this empirical assessment, it makes sense for Ruby to first try `3` and if `Integer#+` was redefined for any reason, fall back to that. It should be much faster for vast majority of normal (not redefined) cases, while it does not break redefinition with some overheads.\n\nThis sort of technique is called deoptimization[[3](http://dl.acm.org/citation.cfm?id=143114)].  Deoptimization is done more or less on other languages / implementations.  Notably JVM related projects has many research in this area. For instance JRuby+Truffle already has rich application of this technique[[4](http://chrisseaton.com/rubytruffle/deoptimizing/)].\n\nWhat is pull-requested here is not the direct C translation of JRuby+Truffle's.  Let me describe what is going on.\n### The deoptimization strategy\n\nSince 1.9, Ruby's interpreter equips a language VM (visible as `::RubyVM` from inside ruby scripts).  It first generates sequences (\"iseq\"s hereafter) of VM instructions (\"insn\"s hereafter), and executes them in series.  The key structure of this mechanism is called `struct rb_iseq_constant_body`.\n\n``` C\nstruct rb_iseq_constant_body {\n    (\u2026snip\u2026)\n\n    unsigned int iseq_size;\n    const VALUE *iseq_encoded; /* encoded iseq (insn addr and operands) */\n\n    (\u2026snip\u2026)\n};\n```\n\nThe `iseq_encoded` field is what VM scans to execute.  This is where we want to optimize.  Prior to do any modifications, we hold a backup of it using `memcpy`.  In case of deoptimization event,  we just overwrite this memory region with backed-up sequence using `memcpy` to revert whatever optimizations that might have been applied to it.\n\nThe upside of this strategy is that it is fairly simple.  Because everything is written in pure C code we have no portability concerns.  Also it is so simple that the deoptimization does not involve the VM states at all, including program counters.  This has advantage when execution of instructions recurs; if we had to update program counters, we must scan the whole VM stacks to keep consistencies between before / after deoptimization process.\n\nThe downside of this strategy is that it restricts what can be optimized.  For instance we cannot reorder instructions, because exceptions might raise inside of reordered sequences.  We cannot change the length of iseq, because the underlying memory region cannot be reallocated.\n\nHowever, even with the given restriction, we can do something.\n### Implemented optimizations\n\nWe have following optimizations in this pull request.\n#### Constant folding\n\nFor instance a `1 + 2` is optimized into `3` like this.\n\n``` diff\n--- /dev/shm/xj79gt      2016-08-17 17:09:31.000000000 +0900\n+++ /dev/shm/1gaaeo      2016-08-17 17:09:31.000000000 +0900\n@@ -20,8 +20,10 @@ local table (size: 2, argc: 0 [opts: 0,\n |------------------------------------------------------------------------\n 0000 trace            256                                             (   7)\n 0002 trace            1                                               (   8)\n-0004 putobject_OP_INT2FIX_O_1_C_\n-0005 putobject        2\n-0007 opt_plus         <callinfo!mid:+, argc:1, ARGS_SIMPLE>, <callcache>\n+0004 putobject        3\n+0006 nop\n+0007 nop\n+0008 nop\n+0009 nop\n 0010 trace            512                                             (   9)\n 0012 leave                                                            (   8)\n```\n\nThe `nop`s are introduced to meet \"no PC modification\" restriction.  In order to implement this, the `opt_plus` instruction is modified to detect a `putobject`-`putobject`-`opt-plus` sequence.  Then it calculates the computation as usual, and overwrites itself with the sequence like above diff.\n\nRuby-level constants (like `::Object`) are also subject to fold.  They are resolved and replaced to `putobject` with the identical value.\n#### `send` elimination\n\nTypical ruby script consists of many method invocations.  They are represented in `send` or its variant instructions in an iseq.  If they are optimized, the effect should not be marginal.  The problem is a method call is not always optimizable.  We have to determine whether we can skip calling.\n\nIn order to do so a method is called as usual for the first time, and checked whether it has any side effects or not.  If a method does not contain any side effects, it (more precisely, its underlying iseq) is marked as being \"pure\".  Next time when the same method is called, we can consider eliminating the call to it.\n\nHowever a method that is not pure is not always NG to optimize.  A method can of course call another method.  A method that is not pure can be simply not checked yet.  So a method has 3 states namely \"pure\", \"not pure\", and \"unpredictable\".  Every methods start their life as being unpredictable.  Once its calling methods are all predicted to be pure, and itself has no side-effects, the state is updated to be pure.\n\n``` C\nenum insn_purity {\n    insn_is_pure          = Qtrue,\n    insn_is_not_pure      = Qfalse,\n    insn_is_unpredictable = Qnil,\n};\n```\n\nSide effect that we care includes:\n- Writes to variables other than local ones,\n- Definition of classes,\n- Call of methods that are not pure,\n- Call of C functions,\n  - C functions are unable to check so we think they are all NG.\n- Yielding blocks.\n\nOnce we know a method is pure, it is safe to eliminate a call to that method which immediately discards its return value(s).  Note however, that even on such situations, evaluations of method arguments are not always eligible to be eliminated.  They can have their own side effects.  We just eliminate the `send` variant instruction and not its caller site setup, like following diff:\n\n``` diff\n--- /dev/shm/165rrgd     2016-08-17 10:44:10.000000000 +0900\n+++ /dev/shm/jd0rcj      2016-08-17 10:44:10.000000000 +0900\n@@ -23,8 +23,10 @@ local table (size: 2, argc: 0 [opts: 0,\n 0004 putself\n 0005 putself\n 0006 opt_send_without_block <callinfo!mid:n, argc:0, FCALL|VCALL|ARGS_SIMPLE>, <callcache>\n-0009 opt_send_without_block <callinfo!mid:m, argc:1, FCALL|ARGS_SIMPLE>, <callcache>\n-0012 adjuststack      1\n+0009 adjuststack      2\n+0011 nop\n+0012 nop\n+0013 nop\n 0014 trace            1                                               (  16)\n 0016 putnil\n 0017 trace            512                                             (  17)\n```\n\nThis is how a `m(n())` is optimized, where method `m` is pure but `n` is not.\n#### Elimination of variable assignments\n\nAs we see, method calls can not be eliminated when its return value is used.  In order to relax this we would like to skip assignments of variables if possible.\n\nHowever this is not easy to do precisely.  A variable's liveness shall be analyzed.  All types of variables except local ones are almost unable to analyze.  Also because we have restriction on what is allowed here due to deoptimization process, massive iseq rearrangements like SSA conversion is not doable.\n\nIn this pull request a very limited version of variable liveness analysis is implemented.  Only\nlocal variables which are never referenced (assigned then made garbage immediately) are detected, then eliminated if possible.  This is not the only thing that could be done theoretically, but practically the easiest to detect so we do this as a bridgehead to further optimizations.\n\nNote we have to check iseqs recursively; because local variables are reachable from inside of a block, and a block is represented in a separate iseq, which means we have to check all possible iseqs that can reach a local variable to ensure no references to it exists.\n\nAfter checking for usages, a useless assignment can be eliminated like this:\n\n``` diff\n--- /dev/shm/1p1dusf     2016-08-25 18:06:58.000000000 +0900\n+++ /dev/shm/1kpw0qe     2016-08-25 18:06:58.000000000 +0900\n@@ -17,10 +17,14 @@ local table (size: 3, argc: 1 [opts: 0,\n [ 3] i<Arg>     [ 2] x\n 0000 trace            256                                             (  12)\n 0002 trace            1                                               (  13)\n-0004 putself\n-0005 getlocal_OP__WC__0 3\n-0007 opt_send_without_block <callinfo!mid:m, argc:1, FCALL|ARGS_SIMPLE>, <callcache>\n-0010 setlocal_OP__WC__0 2\n+0004 nop\n+0005 nop\n+0006 nop\n+0007 nop\n+0008 nop\n+0009 nop\n+0010 nop\n+0011 nop\n 0012 trace            1                                               (  14)\n 0014 putnil\n 0015 trace            512                                             (  15)\n```\n### Experiments\n\nTo determine effectiveness of this approach we took experiments on my environment.  This machine equips `Intel(R) Core(TM)2 Duo CPU T7700` CPU and runs Ubuntu 16.04.  The image below is a `make benchmark` result against ruby 2.4.0dev.\n\n![](https://cloud.githubusercontent.com/assets/15377/17991527/6edc3642-6b7a-11e6-9ac6-75262128c043.png)\n\nLooking at the benchmark, the result is (generally speaking) similar to 2.4, with several exceptional cases which speeds up.  The most improved `vm2_bigarray*` got huge speedup because generation of a big array is eliminated at all.  Other improved benchmarks shows optimizations described above works quite well.\n\nIt is worth noting that the `vm2_eval*` result is 0.933 i.e. `eval` is only 2.7% slow compared to no optimization.  This can be considered as deoptimization preparation cost, and it means overhead is quite small.\n### Conclusions\n\nImplemented a deoptimization engine for ruby and several optimizations on top of it.  The proposed deoptimization strategy is lightweight so that activities like `eval` works without huge overheads.\n\nThe author is not willing to argue this is the only best optimization technique that we know.  Rather, even if it is suboptimal, the benchmark results show that the optimizations proposed here gains considerable amount of speed up.  This is why ruby is said to be slow; it is not optimized at all.  Any trivial optimizations should significantly impact it.\n\nWe believe ruby should have optimizations implemented.\n### Future works\n\nMore optimizations can be thought on top of this deoptimization engine.  For instance branches with constant expressions could be relaxed to unconditional jumps.  More analysis on variable liveness could eliminate more of them.  Perversely, we could think of adding new local variables, like to eliminate common subexpressions.\n\nThe deoptimization strategy is subject to be improved.  If we can suffer more slowdown of `eval`, more fine-grained setup like three-address code could be thought of.  In order to do so a deoptimization engine should be able to revert IR conversion.\n\n</details>\n", "labels": [], "number": 1419, "updated_at": "2018-02-23 03:07:16", "user": 15377, "closed_at": null, "id": 173351229, "title": "Deoptimization Engine", "url": "https://api.github.com/repos/ruby/ruby/issues/1419", "created_at": "2016-08-26 01:52:38", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/242865730", "text": "I read through this a bit and have a question: can it deopt during a method body? If I'm reading it right, the deopt can only occur immediately before entry into the method, which means off-thread changes won't be seen until you re-enter the optimized method again. Is that correct?\n", "created_at": "2016-08-26 22:19:58", "user": 10135, "id": 242865730}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/242890774", "text": "@headius very good point.  My answer is yes and no.  On this patch deoptimizations can occur at two points:\n- at the very beginning of a method, during construction of stack frame: https://github.com/ruby/ruby/pull/1419/commits/523120808bed6a54ced3cd8f17d1cf6a065678bf#diff-347392b62c9edab3c8ab5fb0d71a012fR196\n  - This is expected to purge a stale optimized sequence.\n- right after a method call returns. https://github.com/ruby/ruby/pull/1419/commits/523120808bed6a54ced3cd8f17d1cf6a065678bf#diff-d52fa5b396928e0544140fd48f329543R126\n  - Redefinitions ultimately happen inside of some C functions defined elsewhere.  From a ruby script's point of view calling a C function is done via calling a method.  So every time we call a method, there are chances for redefinitions.  We have to make sure.\n\nIn short, inter-thread method tampering is not checked explicitly.  There are chances for deoptimizations during a method execution, but not immediately when another thread changed something.\n\nI think we can detect off-thread changes.  For now we have GVL so luckily we only need to check it right after when we acquire GVL.  That should suffice for now.  If we decide to give up GVL, we need to introduce some sort of thread checkpoint instead.\n", "created_at": "2016-08-27 02:37:51", "user": 15377, "id": 242890774}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/242894300", "text": "pushed https://github.com/ruby/ruby/pull/1419/commits/2f7bfbfdfc21f988525c6be276e8847384a5fbe9.  It checks for VM timestamp every time context switch hapens.\n", "created_at": "2016-08-27 04:02:28", "user": 15377, "id": 242894300}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/242950532", "text": "Another option could be to have any operation which will cause deoptimisation to do the work to deoptimise the effected methods itself, before it transfers control back to them by releasing the GVL. Then the fast path (optimised methods) doesn't have to do a check. If they're still running, then they didn't have to deoptimise.\n\nThis is an advantage of the GVL. You shouldn't have to _ever_ check if a method should deoptimise, if whoever causes the deoptimisation does the deoptimisation work itself. It only gets slightly more complicated with parallel threads, where you need to stop the world first.\n", "created_at": "2016-08-28 01:30:41", "user": 341094, "id": 242950532}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/242956843", "text": "@chrisseaton true.\n\nHowever we now don't manage which method is optimized in which way so we have to start managing that part.  Because methods are subject to be GCed, management structure (if any) needs to have some sort of weak reference.  I think this is a bit too large to include in this pull request.\n\nThere is another possible way to know which one to deopt; scan all methods every time deoptimization is requested.  I doubt if this can be done in a timely fashion.\n", "created_at": "2016-08-28 05:15:23", "user": 15377, "id": 242956843}, {"reactions": {"heart": [272143]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/243186830", "text": "@shyouhei Oh indeed, it should not be difficult to detect that there's been a deoptimization event across threads. The tricky bit will be deoptimizing the currently-executing iseqs without losing ipc, stack state, etc. I don't think that part exists yet, correct?\n", "created_at": "2016-08-29 17:06:48", "user": 10135, "id": 243186830}, {"reactions": {"+1": [10135]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/243284409", "text": "@headius no.  I mean, you are correct.  That (avoiding to touch VM states) is why we don't see considerable deopt overheads in above benchmarks.  @ko1 commented in-person that I would need to juggle VM states sooner or later I continue to develop, but not yet in this pull request.  It is still just patching iseqs.\n", "created_at": "2016-08-29 23:06:01", "user": 15377, "id": 243284409}, {"reactions": {"+1": [82408]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/248992140", "text": "Is there anything holding this back atm?\n", "created_at": "2016-09-22 18:44:04", "user": 199018, "id": 248992140}, {"reactions": {"heart": [15377]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/249024275", "text": "Builds on `Apple LLVM version 8.0.0 (clang-800.0.40)` with a small change (else bus error on `memcpy`):\n\n``` diff\ndiff --git a/optimize.c b/optimize.c\nindex c0fee33..c9e666f 100644\n--- a/optimize.c\n+++ b/optimize.c\n@@ -637,7 +637,7 @@ iseq_analyze(rb_iseq_t *iseq)\n     }\n }\n\n-static const VALUE wipeout_pattern[8]; /* maybe 5+2==7 should suffice? */\n+static VALUE wipeout_pattern[8]; /* maybe 5+2==7 should suffice? */\n static VALUE adjuststack;\n static VALUE nop;\n static VALUE putobject;\n\n```\n", "created_at": "2016-09-22 20:51:38", "user": 199, "id": 249024275}, {"reactions": {"+1": [199018, 1059480, 2723477]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/249905980", "text": "Is this moving forward? Is there anything we can do to help?\n", "created_at": "2016-09-27 15:45:29", "user": 82408, "id": 249905980}, {"reactions": {"+1": [50499, 969118, 679198, 1059480, 1702808]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/249946474", "text": "> Is there anything we can do to help?\n\nSome suggestions:\n1. Try to run it with your own app or other software.\n2. Try to break it, causing a crash or incorrect behavior.\n3. Benchmark it.\n4. Review and critique the idea and implementation.\n", "created_at": "2016-09-27 18:01:39", "user": 199, "id": 249946474}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253207146", "text": "I'm seeing errors when running rake's test suite:\n[rake_tests_output.txt](https://github.com/ruby/ruby/files/524533/rake_tests_output.txt)\n\nand errors when running `bundle` for rails:\n[rails_bundle_output.txt](https://github.com/ruby/ruby/files/524542/rails_bundle_output.txt)\n", "created_at": "2016-10-12 13:02:54", "user": 4067, "id": 253207146}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253918112", "text": "I get a different error on \"make\". I'm building with CLang on Mac.\n\n[deopt_make_errors.txt](https://github.com/ruby/ruby/files/530447/deopt_make_errors.txt)\n", "created_at": "2016-10-14 21:00:45", "user": 82408, "id": 253918112}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/254024342", "text": "Thank you.  I'm looking at the logs.\n", "created_at": "2016-10-16 03:02:06", "user": 15377, "id": 254024342}, {"reactions": {"hooray": [199], "+1": [349175, 704204, 199018, 1566689, 2085622]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/256302846", "text": "OK, after close inspection I found several bugs and fixed them all.  It now bundles and runs Rails 5.0.0.1, at least for me.\n", "created_at": "2016-10-26 10:00:18", "user": 15377, "id": 256302846}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/256345843", "text": "how come the appveyor test results aren't public?\n", "created_at": "2016-10-26 13:23:29", "user": 199018, "id": 256345843}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/256492515", "text": "Still doesn't compile on Mac with CLang. I have changes locally that allow it to build but segfault. I've attached the \"git diff\". I'll try to get it to build and run successfully.\n[deopt_mac_patch.txt](https://github.com/ruby/ruby/files/554536/deopt_mac_patch.txt)\n", "created_at": "2016-10-26 22:11:33", "user": 82408, "id": 256492515}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/256522826", "text": "Hmm.  Thank you.  I've not tested this against clang so far.  Will take a look.\n", "created_at": "2016-10-27 01:29:19", "user": 15377, "id": 256522826}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/265815043", "text": "[Here](https://gist.github.com/rye/b413a74530be8ae59d674830d53ac5dc) is the Make output when I compile using `clang`.\r\n\r\nEDIT: Link to gist rather than dump all the output into here.", "created_at": "2016-12-08 18:25:14", "user": 1566689, "id": 265815043}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/310867427", "text": "any status with this one? Is almost one year old :)", "created_at": "2017-06-24 21:39:47", "user": 969118, "id": 310867427}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/310979711", "text": "Interested in this one as well. Any news?", "created_at": "2017-06-26 07:06:05", "user": 392754, "id": 310979711}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/310988908", "text": "Me also.", "created_at": "2017-06-26 07:56:36", "user": 150547, "id": 310988908}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/311011411", "text": "@pedroaliens @shyouhei any update on this issue? ", "created_at": "2017-06-26 09:38:52", "user": 7430071, "id": 311011411}, {"reactions": {"+1": [8417720, 386234, 50499]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/311012005", "text": "Folks, piling on doesn't help expedite an issue.", "created_at": "2017-06-26 09:41:29", "user": 41963, "id": 311012005}, {"reactions": {"heart": [50499, 2276631, 802339, 1702808, 199018, 969118, 392754, 50975, 9436]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/311021115", "text": "Hi, quick update is that it's still work in progress.  I got comments from other core-devs including @ko1 , so I think I need his review to merge this, once after I finished on peaceful update.\r\n\r\nThank you for your interest!", "created_at": "2017-06-26 10:23:23", "user": 15377, "id": 311021115}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/320290036", "text": "I successfully made and installed this, but when I tried running bundle install, I got a segfault:\r\n```\r\n$ sudo bundle install # happens with and without sudo, though\r\nDon't run Bundler as root. Bundler can ask for sudo if it is needed, and installing your\r\nbundle as root will break this application for all non-root users on this machine.\r\nFetching gem metadata from https://rubygems.org/./usr/local/lib/ruby/2.4.0/net/http.rb:939: [BUG] Segmentation fault at 0x00000000000010\r\nruby 2.4.0dev (2016-07-22 deoptimization 55727) [x86_64-linux]\r\n\r\n-- Control frame information -----------------------------------------------\r\nc:0023 p:---- s:0138 e:000137 CFUNC  :wait_readable\r\nc:0022 p:0701 s:0134 E:002290 METHOD /usr/local/lib/ruby/2.4.0/net/http.rb:939\r\nc:0021 p:0008 s:0121 e:000120 METHOD /usr/local/lib/ruby/2.4.0/net/http.rb:869\r\nc:0020 p:0076 s:0118 e:000117 METHOD /usr/local/lib/ruby/2.4.0/net/http.rb:864\r\nc:0019 p:0045 s:0115 e:000114 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb:702\r\nc:0018 p:0530 s:0110 E:001a50 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb:633\r\nc:0017 p:0041 s:0097 e:000096 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb:996\r\nc:0016 p:0148 s:0084 e:000083 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/fetcher/downloader.rb:50\r\nc:0015 p:0048 s:0075 e:000074 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/fetcher/downloader.rb:16\r\nc:0014 p:0028 s:0067 e:000066 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/fetcher/compact_index.rb:116\r\nc:0013 p:0161 s:0061 e:000060 BLOCK  /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/compact_index_client/updater.rb:50\r\nc:0012 p:0048 s:0054 e:000053 METHOD /usr/local/lib/ruby/2.4.0/tmpdir.rb:89\r\nc:0011 p:0026 s:0047 e:000046 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/compact_index_client/updater.rb:30\r\nc:0010 p:0068 s:0040 e:000039 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/compact_index_client.rb:81\r\nc:0009 p:0151 s:0035 e:000034 METHOD /usr/local/lib/ruby/gems/2.4.0/gems/bundler-1.15.3/lib/bundler/compact_index_client.rb:97\r\n```", "created_at": "2017-08-04 16:15:03", "user": 199018, "id": 320290036}], "assignees": [15377, 15377], "state": "open", "is-pull-request": true}, "223263042": {"text": "In reference to Feature [#13108](https://bugs.ruby-lang.org/issues/13108), I explicitly documented `Enumerable#sum` for Integer Ranges as it is a different and significant difference. ", "labels": [], "number": 1593, "updated_at": "2018-02-23 03:07:35", "user": 9064062, "closed_at": null, "id": 223263042, "title": "Add explicit documentation for Integer Range Summation", "url": "https://api.github.com/repos/ruby/ruby/issues/1593", "created_at": "2017-04-21 03:13:42", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "292288323": {"text": "* ruby.c (f_executed_p): returns true when file is executed directly.\r\nreturns false when file is required file. [Feature #4824]\r\n\r\nrefs\r\n--\r\nFeature #4824: Provide method Kernel#executed? - Ruby trunk - Ruby Issue Tracking System https://bugs.ruby-lang.org/issues/4824", "labels": [], "number": 1802, "updated_at": "2018-02-23 03:07:43", "user": 15604014, "closed_at": null, "id": 292288323, "title": "[Feature #4824]ruby.c: implement Kernel#executed?", "url": "https://api.github.com/repos/ruby/ruby/issues/1802", "created_at": "2018-01-29 05:28:14", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "285843278": {"text": "**Add a faster Prime:prime? algorithm**\r\nI worked the other day on a problem from the Euler Project and found myself using Prime:prime? to iterate over a large set of numbers. While doing that I noticed that the Prime:prime? method was a little slow. I swapped it with another algorithm I found on [SO](https://stackoverflow.com/questions/1801391/what-is-the-best-algorithm-for-checking-if-a-number-is-prime). The result was incredible:\r\n```bash\r\n$ (Prime:prime?) Time to complete (10 million): 205.742023\r\n$ (Prime:prime?) 664579 prime numbers found\r\n\r\n$ (new_prime?) Time to complete (10 million): 50.634685\r\n$ (new_prime?) 664579 prime numbers found\r\n```\r\nAs you can see iterating over 10 million numbers, the new algorithm is able to find the same prime numbers 4 times faster. I ran the tests locally and everything seems to work fine.\r\nCould you double check ?\r\n  ", "labels": [], "number": 1786, "updated_at": "2018-02-23 03:07:43", "user": 11302907, "closed_at": null, "id": 285843278, "title": "Improve Prime:prime? algorithm up to 4 times faster", "url": "https://api.github.com/repos/ruby/ruby/issues/1786", "created_at": "2018-01-03 23:46:51", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/355179285", "text": "sorry, I ran the `spec` tests at first and didn't notice the `test` folder which is why I had to push 2 fixes.", "created_at": "2018-01-04 01:57:48", "user": 11302907, "id": 355179285}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/356767956", "text": "I ran the proposed method, and did see a *slight* (20%) improvement, but no where near the 400% speedup claimed. I'd be curious to see the actual test ran, rather than just the result @Mycroft1891 ?\r\n\r\nHere is my *complete* benchmarking code, with results:\r\n\r\n```\r\nclass Integer\r\n  def prime_orig?\r\n    return self >= 2 if self <= 3\r\n    return true if self == 5\r\n    return false unless 30.gcd(self) == 1\r\n    (7..Integer.sqrt(self)).step(30) do |p|\r\n      return false if\r\n        self%(p)    == 0 || self%(p+4)  == 0 || self%(p+6)  == 0 || self%(p+10) == 0 ||\r\n        self%(p+12) == 0 || self%(p+16) == 0 || self%(p+22) == 0 || self%(p+24) == 0\r\n    end\r\n    true\r\n  end\r\n\r\n  def prime_new?\r\n    return false if self <= 1\r\n    return true  if self == 2 || self == 3\r\n    return false if self % 2 == 0 || self % 3 == 0\r\n    i = 5\r\n    w = 2\r\n    while i * i <= self\r\n      return false if self % i == 0\r\n      i += w\r\n      w = 6 - w\r\n    end\r\n    true\r\n  end\r\nend\r\n\r\nrequire 'benchmark'\r\niterations = 100_000\r\nnumbers = (-100..1_000).to_a\r\n\r\nBenchmark.bmbm(20) do |bm|\r\n  bm.report('Original method') do\r\n    iterations.times do\r\n      numbers.select(&:prime_orig?)\r\n    end\r\n  end\r\n\r\n  bm.report('New method') do\r\n    iterations.times do\r\n      numbers.select(&:prime_new?)\r\n    end\r\n  end\r\nend\r\n\r\nRehearsal --------------------------------------------------------\r\nOriginal method       31.264767   0.097343  31.362110 ( 31.447996)\r\nNew method            24.547395   0.131066  24.678461 ( 24.687701)\r\n---------------------------------------------- total: 56.040571sec\r\n\r\n                           user     system      total        real\r\nOriginal method       31.111096   0.040542  31.151638 ( 31.177937)\r\nNew method            24.643408   0.160427  24.803835 ( 24.895586)\r\n```\r\n\r\nNote that real world usage of `Integer#prime?` may differ from the above test case, so this is by no means a definitive result.\r\n\r\nEdit: In fact, after a little more experimentation, on my machine I found that the new method is increasingly **slower** for integers greater than about `10_000`. For example, for integers in the ballpark of `20_000_000`, this new method is roughly *half* the speed of the original.", "created_at": "2018-01-10 23:06:47", "user": 7573396, "id": 356767956}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/357006554", "text": "My test was much simpler, I will try out yours a little later.\r\nFor now here is my test:\r\n\r\n```\r\nrequire('prime')\r\nclass Integer\r\n\r\n  def prime_new?\r\n    return false if self <= 1\r\n    return true  if self == 2 || self == 3\r\n    return false if self % 2 == 0 || self % 3 == 0\r\n    i = 5\r\n    w = 2\r\n    while i * i <= self\r\n      return false if self % i == 0\r\n      i += w\r\n      w = 6 - w\r\n    end\r\n    true\r\n  end\r\nend\r\n\r\n\r\nruby_prime = []\r\nmy_prime = []\r\n\r\nt = Time.now\r\n10_000_000.times do |i|\r\n  ruby_prime.push(i) if Prime.prime?(i)\r\nend\r\nputs \"(Prime) Time to complete (100k): #{Time.now - t}\"\r\nputs \"(Prime) #{ruby_prime.count} prime numbers found\\n\\n\"\r\n\r\nb = Time.now\r\n10_000_000.times do |i|\r\n  my_prime.push(i) if i.isprime?\r\nend\r\n\r\nputs \"(isprime?) Time to complete (100k): #{Time.now - b}\"\r\nputs \"(isprime?) #{my_prime.count} prime numbers found\\n\"\r\n```\r\n\r\nAs you increase the number of times, the time difference becomes greater. I put the integer class extension in a different file and imported it like Prime actually at the top to make it a little more fair.", "created_at": "2018-01-11 17:48:23", "user": 11302907, "id": 357006554}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/357013801", "text": "@Mycroft1891 Could you re-write the script to use `Benchmark` or [`benchmark-ips`](https://github.com/evanphx/benchmark-ips) like @tom-lord did? Also it would be great if you could share comparisons for multiple cases (e.g. each for negative number, 0, 1, 2, 3, small prime number, small non-prime number, large prime number, large non-prime number, etc)", "created_at": "2018-01-11 18:13:26", "user": 386234, "id": 357013801}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/357021981", "text": "@yuki24 Sure here is the same test using Benchmark:\r\n\r\n```\r\nrequire 'benchmark'\r\nrequire 'prime'\r\nrequire './my_prime'\r\n\r\niterations = 1_000_000\r\n\r\nruby_prime = []\r\nmy_prime = []\r\n\r\nBenchmark.bm do |bm|\r\n  bm.report do\r\n    iterations.times do |i|\r\n      ruby_prime.push(i) if Prime.prime?(i)\r\n    end\r\n  end\r\n\r\n  bm.report do\r\n    iterations.times do |i|\r\n      my_prime.push(i) if isprime?(i)\r\n    end\r\n  end\r\nend\r\n```", "created_at": "2018-01-11 18:41:53", "user": 11302907, "id": 357021981}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/357026546", "text": "@Mycroft1891 Thanks for the script. I have a few more comments:\r\n\r\n * Inline the `./my_prime` so anyone can run your script\r\n * Remove the use of the `push` method. It'd just add some overhead to the benchmark result\r\n * As I mentioned above, benchmark more cases. At least with a negative number, 0, 1, 2, 3, small prime number, small non-prime number, large prime number, large non-prime number. The `prime?` method has a lot of conditionals and it is important to understand what's significantly faster and what's slightly faster.", "created_at": "2018-01-11 18:58:23", "user": 386234, "id": 357026546}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/357214910", "text": "@yuki24 @tom-lord I found out why I saw such a big difference. If you run the test using `Prime.prime?(n)` the performance drops by a lot while when you use `n.prime?` it is much faster as @tom-lord noted.\r\nI created a `my_prime.rb` file this is inside it:\r\n\r\n```\r\n# my_prime.rb\r\nclass Prime\r\n  def isprime?(n)\r\n    return false if n <= 1\r\n    return true  if n == 2 || n == 3\r\n    return false if n % 2 == 0 || n % 3 == 0\r\n    i = 5\r\n    w = 2\r\n    while i * i <= n\r\n      return false if n % i == 0\r\n      i += w\r\n      w = 6 - w\r\n    end\r\n    true\r\n  end\r\nend\r\n\r\nclass Integer\r\n  def isprime?\r\n    return false if self <= 1\r\n    return true  if self == 2 || self == 3\r\n    return false if self % 2 == 0 || self % 3 == 0\r\n    i = 5\r\n    w = 2\r\n    while i * i <= self\r\n        return false if self % i == 0\r\n        i += w\r\n        w = 6 - w\r\n    end\r\n    true\r\n  end\r\nend\r\n\r\n```\r\n\r\nAs you can see I extended both the Integer and the Prime class just to make it similar.\r\n\r\nI created a new benchmark covering:\r\n- negative number (-100..1000)\r\n- small prime numbers (first 2000)\r\n- small non prime numbers (any non prime smaller than 1000)\r\n- large prime numbers (primes in this range 10_999_000..11_000_000)\r\n- large non prime numbers (non primes in this range 10_999_000..11_000_000)\r\n\r\nIn the first test, I run it comparing `n.prime?` vs. `n.isprime?` the second is the new prime algorithm.\r\n\r\n```\r\nrequire 'benchmark'\r\nrequire 'prime'\r\nrequire './my_prime'\r\n\r\none_million      = 1_000_000\r\nten_thousand     = 10_000\r\nthousand         = 1_000\r\n\r\nwith_negative    = (-100..1_000).to_a\r\nsmall_non_primes = (0..1_000).reject {|n| Prime.prime?(n) }\r\nsmall_primes     = Prime.take(2000)\r\nlarge_non_primes = (10_999_000..11_000_000).reject {|n| Prime.prime?(n) }\r\nlarge_primes     = (10_999_000..11_000_000).select {|n| Prime.prime?(n) }\r\n\r\nBenchmark.bmbm(20) do |bm|\r\n  bm.report('Old: 1_000_000 * prime?') do\r\n    one_million.times do |i|\r\n      i.prime?\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000_000 * prime?') do\r\n    one_million.times do |i|\r\n      i.isprime?\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 10_000 * -100 to 1_000') do\r\n    ten_thousand.times do |i|\r\n      with_negative.select(&:prime?)\r\n    end\r\n  end\r\n\r\n  bm.report('New: 10_000 * -100 to 1_000') do\r\n    ten_thousand.times do |i|\r\n      with_negative.select(&:isprime?)\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 1_000 * small non primes') do\r\n    thousand.times do |i|\r\n      small_non_primes.select(&:prime?)\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000 * small non primes') do\r\n    thousand.times do |i|\r\n      small_non_primes.select(&:isprime?)\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 1_000 * small primes') do\r\n    thousand.times do |i|\r\n      small_primes.select(&:prime?)\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000 * small primes') do\r\n    thousand.times do |i|\r\n      small_primes.select(&:isprime?)\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 1_000 * large primes') do\r\n    thousand.times do |i|\r\n      large_primes.select(&:prime?)\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000 * large primes') do\r\n    thousand.times do |i|\r\n      large_primes.select(&:isprime?)\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 1_000 * large non primes') do\r\n    thousand.times do |i|\r\n      large_non_primes.select(&:prime?)\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000 * large non primes') do\r\n    thousand.times do |i|\r\n      large_non_primes.select(&:isprime?)\r\n    end\r\n  end\r\nend\r\n```\r\nThe results are almost the same, sometimes the new algorithm is faster while most of the times the old one is faster: \r\n\r\n```\r\nRehearsal -----------------------------------------------------------------\r\nOld: 1_000_000 * prime?         1.405529   0.007792   1.413321 (  1.428931)\r\nNew: 1_000_000 * prime?         2.073816   0.012818   2.086634 (  2.131261)\r\nOld: 10_000 * -100 to 1_000     4.592670   0.025376   4.618046 (  4.672404)\r\nNew: 10_000 * -100 to 1_000     3.636590   0.052335   3.688925 (  3.743397)\r\nOld: 1_000 * small non primes   0.286702   0.002224   0.288926 (  0.291118)\r\nNew: 1_000 * small non primes   0.204080   0.001687   0.205767 (  0.207332)\r\nOld: 1_000 * small primes       3.848818   0.022083   3.870901 (  3.911539)\r\nNew: 1_000 * small primes       5.210528   0.035932   5.246460 (  5.318403)\r\nOld: 1_000 * large primes       3.175398   0.018349   3.193747 (  3.244483)\r\nNew: 1_000 * large primes       5.894557   0.031974   5.926531 (  5.989830)\r\nOld: 1_000 * large non primes   1.273114   0.007360   1.280474 (  1.298590)\r\nNew: 1_000 * large non primes   1.761014   0.010536   1.771550 (  1.803974)\r\n------------------------------------------------------- total: 33.591282sec\r\n\r\n                                    user     system      total        real\r\nOld: 1_000_000 * prime?         1.442458   0.008244   1.450702 (  1.471786)\r\nNew: 1_000_000 * prime?         2.097896   0.012572   2.110468 (  2.142132)\r\nOld: 10_000 * -100 to 1_000     4.709277   0.026490   4.735767 (  4.794737)\r\nNew: 10_000 * -100 to 1_000     3.574214   0.027443   3.601657 (  3.657275)\r\nOld: 1_000 * small non primes   0.279802   0.002282   0.282084 (  0.286573)\r\nNew: 1_000 * small non primes   0.222431   0.001646   0.224077 (  0.227809)\r\nOld: 1_000 * small primes       3.824703   0.024839   3.849542 (  3.891357)\r\nNew: 1_000 * small primes       5.274420   0.030545   5.304965 (  5.372510)\r\nOld: 1_000 * large primes       3.062497   0.016671   3.079168 (  3.110922)\r\nNew: 1_000 * large primes       5.765497   0.030927   5.796424 (  5.870993)\r\nOld: 1_000 * large non primes   1.225203   0.007635   1.232838 (  1.254354)\r\nNew: 1_000 * large non primes   1.758376   0.008997   1.767373 (  1.790090)\r\n```\r\n\r\nEverything changes when you compare `Prime.prime?(n)` vs. `Prime.isprime?(n)` once again the second one is the new prime method.\r\n\r\n```\r\nrequire 'benchmark'\r\nrequire 'prime'\r\nrequire './my_prime'\r\n\r\none_million      = 1_000_000\r\nten_thousand     = 10_000\r\nthousand         = 1_000\r\n\r\nwith_negative    = (-100..1_000).to_a\r\nsmall_non_primes = (0..1_000).reject {|n| Prime.prime?(n) }\r\nsmall_primes     = Prime.take(2000)\r\nlarge_non_primes = (10_999_000..11_000_000).reject {|n| Prime.prime?(n) }\r\nlarge_primes     = (10_999_000..11_000_000).select {|n| Prime.prime?(n) }\r\n\r\nBenchmark.bmbm(20) do |bm|\r\n  bm.report('Old: 1_000_000 * prime?') do\r\n    one_million.times do |i|\r\n      Prime.prime?(i)\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000_000 * prime?') do\r\n    one_million.times do |i|\r\n      i.isprime?\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 10_000 * -100 to 1_000') do\r\n    ten_thousand.times do |i|\r\n      with_negative.select { |n| Prime.prime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('New: 10_000 * -100 to 1_000') do\r\n    ten_thousand.times do |i|\r\n      with_negative.select { |n| Prime.isprime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 1_000 * small non primes') do\r\n    thousand.times do |i|\r\n      small_non_primes.select { |n| Prime.prime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000 * small non primes') do\r\n    thousand.times do |i|\r\n      small_non_primes.select { |n| Prime.isprime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 1_000 * small primes') do\r\n    thousand.times do |i|\r\n      small_primes.select { |n| Prime.prime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000 * small primes') do\r\n    thousand.times do |i|\r\n      small_primes.select { |n| Prime.isprime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 1_000 * large primes') do\r\n    thousand.times do |i|\r\n      large_primes.select { |n| Prime.prime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000 * large primes') do\r\n    thousand.times do |i|\r\n      large_primes.select { |n| Prime.isprime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('Old: 1_000 * large non primes') do\r\n    thousand.times do |i|\r\n      large_non_primes.select { |n| Prime.prime?(n) }\r\n    end\r\n  end\r\n\r\n  bm.report('New: 1_000 * large non primes') do\r\n    thousand.times do |i|\r\n      large_non_primes.select { |n| Prime.isprime?(n) }\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThese are the results I saw when I tested it:\r\n\r\n```\r\nRehearsal -----------------------------------------------------------------\r\nOld: 1_000_000 * prime?         9.707928   0.056095   9.764023 (  9.884189)\r\nNew: 1_000_000 * prime?         2.068627   0.005823   2.074450 (  2.088193)\r\nOld: 10_000 * -100 to 1_000    27.125947   0.105004  27.230951 ( 27.481636)\r\nNew: 10_000 * -100 to 1_000     7.366718   0.038283   7.405001 (  7.492338)\r\nOld: 1_000 * small non primes   1.822184   0.013414   1.835598 (  1.863551)\r\nNew: 1_000 * small non primes   0.495780   0.002681   0.498461 (  0.503347)\r\nOld: 1_000 * small primes      23.748546   0.115993  23.864539 ( 24.070753)\r\nNew: 1_000 * small primes       6.046003   0.032608   6.078611 (  6.144513)\r\nOld: 1_000 * large primes      23.265469   0.096873  23.362342 ( 23.591089)\r\nNew: 1_000 * large primes       5.896811   0.034694   5.931505 (  6.014809)\r\nOld: 1_000 * large non primes   8.249851   0.045913   8.295764 (  8.376780)\r\nNew: 1_000 * large non primes   2.080070   0.011458   2.091528 (  2.110891)\r\n------------------------------------------------------ total: 118.432773sec\r\n\r\n                                    user     system      total        real\r\nOld: 1_000_000 * prime?         9.740492   0.054909   9.795401 (  9.903361)\r\nNew: 1_000_000 * prime?         2.052631   0.011364   2.063995 (  2.087338)\r\nOld: 10_000 * -100 to 1_000    26.913940   0.099397  27.013337 ( 27.217281)\r\nNew: 10_000 * -100 to 1_000     7.545237   0.044933   7.590170 (  7.685570)\r\nOld: 1_000 * small non primes   1.792154   0.010089   1.802243 (  1.821959)\r\nNew: 1_000 * small non primes   0.492120   0.009264   0.501384 (  0.511246)\r\nOld: 1_000 * small primes      23.592904   0.096804  23.689708 ( 23.948073)\r\nNew: 1_000 * small primes       5.971981   0.033575   6.005556 (  6.079808)\r\nOld: 1_000 * large primes      23.149618   0.102074  23.251692 ( 23.496745)\r\nNew: 1_000 * large primes       5.896328   0.029026   5.925354 (  5.996483)\r\nOld: 1_000 * large non primes   8.138648   0.046656   8.185304 (  8.269999)\r\nNew: 1_000 * large non primes   2.098734   0.011617   2.110351 (  2.137368)\r\n```\r\n\r\nBasically `Integer.prime?` is much much faster than `Prime.prime?(n)` \r\n\u4ee5\u4e0a\u3067\u3059", "created_at": "2018-01-12 11:28:46", "user": 11302907, "id": 357214910}, {"reactions": {"+1": [11302907]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/357217793", "text": "So the original comparison was between apples and oranges; you'd compared `Prime.prime?` with `Integer#prime?` \ud83d\ude04\r\n \r\n(I thought it was a bit of odd that this PR is titled `Improve Prime:prime? ...` when you didn't actually touch that method!)\r\n\r\nBased on those performance figures, I don't think there's sufficient justification for changing the implementation. For larger values (where performance is more critical!), the new method performs significantly slower.", "created_at": "2018-01-12 11:43:24", "user": 7573396, "id": 357217793}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/357224822", "text": "@tom-lord Yes, my error. `Integer.prime?` and `Prime.prime?(n)` confused me thus I changed the wrong method. My only question is why do we have 2 ways of checking primes ? I couldn't find in the docs anything about why `Prime.prime?(n)` is so much slower except that it takes an optional generator. Wouldn't it be better to point our that is performs much worse than `Integer.prime?`", "created_at": "2018-01-12 12:20:53", "user": 11302907, "id": 357224822}], "assignees": [], "state": "open", "is-pull-request": true}, "307535695": {"text": "to state what it really does.\r\n\r\nAccording to the documentation, this would be wrong:\r\n\r\n```\r\nc = Complex(Float::MAX, Float::MAX)\r\n=> (1.7976931348623157e+308+1.7976931348623157e+308i)\r\nc.finite?\r\n=> true\r\nc.magnitude.finite?\r\n=> false\r\nc.magnitude\r\n=> Infinity\r\n```\r\n\r\nSame is true for ``Complex#infinite?``", "labels": [], "number": 1848, "updated_at": "2018-03-22 07:43:41", "user": 3799140, "closed_at": null, "id": 307535695, "title": "Update Complex#finite? and Complex#infinite? documenation", "url": "https://api.github.com/repos/ruby/ruby/issues/1848", "created_at": "2018-03-22 07:41:48", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "233140878": {"text": "This pr makes Ruby programmers can build zlib binding without zlib-devel packages. You can build zlib binding with `--enable-bundled-zlib` option.", "labels": [], "number": 1638, "updated_at": "2018-02-23 03:07:36", "user": 12301, "closed_at": null, "id": 233140878, "title": "[EXPERIMENTAL] static link helper of zlib", "url": "https://api.github.com/repos/ruby/ruby/issues/1638", "created_at": "2017-06-02 10:25:45", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/305972724", "text": "appveyor needs `--enable-bundled-zlib`.", "created_at": "2017-06-03 12:40:36", "user": 16700, "id": 305972724}], "assignees": [], "state": "open", "is-pull-request": true}, "212640599": {"text": "The yielding block will be faster around 9%.\r\nThis patch ensures that expand to inline codes in where invoke yielding block.\r\n\r\n* Environment\r\n  - macOS 10.12.3\r\n  - clang 8.0.0 in Xcode 8.2\r\n\r\n* Before\r\n```\r\n                    user     system      total        real\r\nInteger#times   0.930000   0.000000   0.930000 (  0.932125)\r\nArray#each      0.950000   0.000000   0.950000 (  0.957962)\r\nArray#map       1.220000   0.030000   1.250000 (  1.249174)\r\n```\r\n\r\n* After\r\n```\r\n                    user     system      total        real\r\nInteger#times   0.850000   0.000000   0.850000 (  0.853202)\r\nArray#each      0.860000   0.010000   0.870000 (  0.865507)\r\nArray#map       1.120000   0.020000   1.140000 (  1.149939)\r\n```\r\n\r\n* Test code\r\n```\r\nrequire 'benchmark'\r\n\r\nBenchmark.bmbm do |x|\r\n\r\n  ary = (1..10000).to_a\r\n\r\n  x.report \"Integer#times\" do\r\n    20000000.times do\r\n    end\r\n  end\r\n\r\n  x.report \"Array#each\" do\r\n    2000.times do\r\n      ary.each { |x| }\r\n    end\r\n  end\r\n\r\n  x.report \"Array#map\" do\r\n    2000.times do\r\n      ary.map { |x| }\r\n    end\r\n  end\r\n\r\nend\r\n```\r\n\r\nhttps://bugs.ruby-lang.org/issues/13342", "labels": [], "number": 1535, "updated_at": "2018-02-23 03:07:31", "user": 199156, "closed_at": null, "id": 212640599, "title": "Improve yielding block performance", "url": "https://api.github.com/repos/ruby/ruby/issues/1535", "created_at": "2017-03-08 05:21:38", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/284974062", "text": "Use `ALWAYS_INLINE` macro.", "created_at": "2017-03-08 08:06:08", "user": 16700, "id": 284974062}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/284977556", "text": "@nobu Thank you for your review. Updated the code with your suggestion.", "created_at": "2017-03-08 08:24:41", "user": 199156, "id": 284977556}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/304207852", "text": "I think this pull request is related to https://bugs.ruby-lang.org/issues/12599\r\nThis affects the performance if compiled with clang\r\n\r\nIf `inline-threshold` compile flag would be adjusted, I guess this might be unnecessary.\r\n", "created_at": "2017-05-26 07:00:00", "user": 199156, "id": 304207852}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/304335575", "text": "If some functions which is expected to be inlined like `vm_getivar`, which has some constant argument and when it is inlined the content is significantly optimized, are not optimized by clang with default `inline-threshold`, and they are inlined if `inline-threshold` is set as specific size, it sounds reasonable.", "created_at": "2017-05-26 17:02:17", "user": 13423, "id": 304335575}], "assignees": [], "state": "open", "is-pull-request": true}, "119545178": {"text": "This change is about OptionParser.getopts method's return.\n\nWhen same name options that allowed to receive value are specified like this\nlist = [\"--foo\", \"value1\", \"--foo\", \"value2\"]\np OptionParser.getopts(list, \"\", \"foo:\");\nNow will return this {\"foo\"=>\"value2\"},\nOnly last value is accepted.\n\nBut, I think that it's better to return {\"foo\"=>[\"value1\", \"value2\"]}\n", "labels": [], "number": 1119, "updated_at": "2018-02-23 03:07:06", "user": 5457651, "closed_at": null, "id": 119545178, "title": "save values when same name options that allowed value are given.", "url": "https://api.github.com/repos/ruby/ruby/issues/1119", "created_at": "2015-11-30 17:54:16", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "194603363": {"text": "Previous implementation had an issues:\r\n- macros murmur1 assumes murmur_step takes rotation value\r\n  as a second argument\r\n- but murmur_step second argument is \"next block\"\r\n- this makes st_hash_uint and st_hash_end to not mix high bits of\r\n  hash value into lower bits\r\n- this leads to pure hash behavior on doubles and mixing hashes using\r\n  st_hash_uint.\r\n  It didn't matter when bins amount were prime numbers, but it hurts\r\n  when bins are powers of two.\r\n\r\nMistake were created cause of attempt to co-exist Murmur1 and Murmur2\r\nin a same code.\r\n\r\nChange it to single hash-function implementation.\r\n- block function is in a spirit of Murmur functions,\r\n  but handles inter-block dependency a bit better (imho).\r\n- final block is read in bit more optimal way on CPU with unaligned word access,\r\n- final block is mixed in simple way,\r\n- finalizer is taken from MurmurHash3 (it makes most of magic :) )\r\n  (64bit finalizer is taken from\r\n  http://zimbry.blogspot.ru/2011/09/better-bit-mixing-improving-on.html)\r\n\r\nAlso remove ST_USE_FNV1: it lacks implementation of many functions,\r\nand looks to be abandoned", "labels": [], "number": 1503, "updated_at": "2018-02-23 03:07:26", "user": 249427, "closed_at": null, "id": 194603363, "title": "st.c: fix st_hash* functions", "url": "https://api.github.com/repos/ruby/ruby/issues/1503", "created_at": "2016-12-09 14:00:36", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/266021961", "text": "https://bugs.ruby-lang.org/issues/13019", "created_at": "2016-12-09 14:08:41", "user": 249427, "id": 266021961}], "assignees": [], "state": "open", "is-pull-request": true}, "296971622": {"text": "This is a very rough cut that is yet to be merged.\r\nI am just creating a pull request beforehand.", "labels": [], "number": 1817, "updated_at": "2018-02-23 03:07:45", "user": 15377, "closed_at": null, "id": 296971622, "title": "C preprocessor written in pure Ruby.", "url": "https://api.github.com/repos/ruby/ruby/issues/1817", "created_at": "2018-02-14 04:25:00", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "267379565": {"text": "", "labels": [], "number": 1723, "updated_at": "2018-02-23 03:07:39", "user": 2290461, "closed_at": null, "id": 267379565, "title": "vm_core.h: add doxygen document comments", "url": "https://api.github.com/repos/ruby/ruby/issues/1723", "created_at": "2017-10-21 13:19:01", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "181297014": {"text": "This exposes Coverage.result in a slightly more writeable way and allows coverage analysis to reset to a baseline in a safe way.\n\nNote, I wasn't able to figure out how to invalidate the cached pointers in the VM bytecode, so this does `rb_ary_replace` across all the arrays instead. I'd love to see this improved so it were cleaner.\n\nThis is ongoing work to improve the current state of code coverage analysis. I'll be giving a talk on this at rubyconf 2016.\n\nI should also add, this applies cleanly to 2.3 as well.\n\nAlso reported here: https://bugs.ruby-lang.org/issues/12812\n", "labels": [], "number": 1456, "updated_at": "2018-02-23 03:07:20", "user": 9832, "closed_at": null, "id": 181297014, "title": "Added Coverage.result=", "url": "https://api.github.com/repos/ruby/ruby/issues/1456", "created_at": "2016-10-06 00:16:48", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/251838081", "text": "Why do you need to overwrite it, not subtracting older values?\n", "created_at": "2016-10-06 00:34:44", "user": 16700, "id": 251838081}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/251838589", "text": "@nobu thanks for the feedback! Working on it now.\n\n> Why do you need to overwrite it, not subtracting older values?\n\nI'm actually trying to keep the older (baseline) values and reject newer values. This is for a new tool I'm working on (https://github.com/seattlerb/minitest-coverage) that reduces false positives by only recording the coverage for the class under test.\n", "created_at": "2016-10-06 00:39:01", "user": 9832, "id": 251838589}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/251838638", "text": "@nobu `rb_check_hash_type` to check? \n", "created_at": "2016-10-06 00:39:28", "user": 9832, "id": 251838638}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/251839038", "text": "@nobu. done and thanks.\n", "created_at": "2016-10-06 00:42:14", "user": 9832, "id": 251839038}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/251901466", "text": "@zenspider \n\n> I'm actually trying to keep the older (baseline) values and reject newer values. This is for a new tool I'm working on (https://github.com/seattlerb/minitest-coverage) that reduces false positives by only recording the coverage for the class under test.\n\nWhy does Coverage.peek_result not work for your use-case?\n", "created_at": "2016-10-06 08:41:29", "user": 168854, "id": 251901466}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/251907347", "text": "@eregon simply doesn't do what I want... It let's me access the results w/o wiping them... But if I can't reset results, I can't get accurate data. This patch let's me do that.\n\nCome to my talk at rubyconf.\n", "created_at": "2016-10-06 09:08:01", "user": 9832, "id": 251907347}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/251923336", "text": "@nobu If you'd like, when you're happy with this, I'll flatten and push back a clean diff.\n", "created_at": "2016-10-06 10:23:32", "user": 9832, "id": 251923336}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/251953540", "text": "> @eregon simply doesn't do what I want... It let's me access the results w/o wiping them... But if I can't reset results, I can't get accurate data. This patch let's me do that.\n\nBut doing a diff between two `peek_result` would allow that, no?\nIs it because computing the diff is inconvenient?\nWhat do you mean by `accurate`? Only new coverage from a given point?\n\n> Come to my talk at rubyconf.\n\nSorry, I can't go this year.\n", "created_at": "2016-10-06 12:57:48", "user": 168854, "id": 251953540}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252062206", "text": "@eregon because it isn't between two `peek_result` collections. It's between all of them because what you're getting is cumulative. It just gets messy and hard to manage. Taking a baseline (ie, JUST loading the files and storing that off) and then resetting to that between test classes/methods completely changes the game.\n", "created_at": "2016-10-06 19:20:04", "user": 9832, "id": 252062206}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252062296", "text": "Sucks that you can't go. Sorry. \ud83d\ude26\n", "created_at": "2016-10-06 19:20:22", "user": 9832, "id": 252062296}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252077388", "text": "@nobu cleaned and flattened.\n", "created_at": "2016-10-06 20:22:18", "user": 9832, "id": 252077388}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252186091", "text": "@zenspider could you show any short example to demonstrate that the current API makes the result inaccurate?  I (and maybe, @eregon) can't see the problem.\n\nI won't go to rubyconf, but if you are not in a hurry, I can wait for the slides or the movie of your presentation.  (Let me know when it is published.)\n", "created_at": "2016-10-07 08:48:42", "user": 21557, "id": 252186091}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252209773", "text": "@mame I'd prefer to be able to announce at the talk that the patch is in ruby and going into the next release if at all possible.\n\n@mame / @eregon I haven't figured out how to write tests for this thing yet, but I can try to come up with a hypothetical example here:\n\n``` ruby\nclass X\n  def x\n    Y.new.y\n  end\nend\n\nclass Y\n  def y\n    Z.new.z\n  end\nend\n\nclass Z\n  def z\n    # something complex\n  end\nend\n\nrequire \"minitest/autorun\"\n\nclass TestX < Minitest::Test\n  def test_x\n    assert_nil X.new.x\n  end\nend\n```\n\nAssume these are all in appropriately different files and you run this with coverage:\n\n```\nruby -Ilib -rcoverage/start -rcoverage/pruner -e \"require './bad_example.rb'\"\n```\n\nThe coverage on this file is:\n\n```\n[1, 1, 1, null, null, null, 1, 1, 1, null, null, null, 1, 1, null, null, null, null, 1, null, 1, 1, 1, null, null]\n```\n\nor, 100%. And you didn't test the other two classes for correctness. If you then DID want to check them for full coverage, you wouldn't even know where to start. That's false positives.\n\nBut, since `Coverage` currently doesn't allow for resetting the baseline, and clearing (or getting `results`) effectively stops coverage for the rest of the run, you _can't_ do anything to nullify those false positives. It gets way too messy too fast.\n\nOr, I preload everything without any tests running and save off a baseline. Then I run my tests, one test class at a time, and record off the coverage for the class under test (CUT). Every test class I reset to baseline and I merge the actual coverage at report time.\n\nIt is prone to false negatives as it requires good mappings from the test class to the CUT, but I find that vastly preferable (and easily correctable) to false positives.\n", "created_at": "2016-10-07 10:27:48", "user": 9832, "id": 252209773}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252248516", "text": "Thank you.  Indeed, we easily forget to write a test for a common helper function because another test indirectly executes it.  You call this false-positive, don't you?  Though I have no idea that it is really a matter, I understand.\n\nHowever, I cannot understand how this patch addresses your problem.  Even if we can reset the coverage status, we cannot avoid a fact that a common helper function are accidentally executed by another test.\n\nAlso, @tenderlove introduced `Coverage.peek_result` for capturing \"per-test\" coverage information.  See [this ticket](https://bugs.ruby-lang.org/issues/10816).  I think you can use it to capture \"per-class\" coverage.  I admit the API is not so easy to use (we need to calculate difference between two sets of captured coverage information).  I'd like to hear @tenderlove's opinion.\n", "created_at": "2016-10-07 13:13:30", "user": 21557, "id": 252248516}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252371383", "text": "> However, I cannot understand how this patch addresses your problem. Even if we can reset the coverage status, we cannot avoid a fact that a common helper function are accidentally executed by another test.\n\nCan you explain the confusion further?\n\nResetting back to a baseline per test class allows me to negate the false positives. If we then run a `TestY`, we'll start with zeros again and any tests that hit `Y`will be recorded accurately.\n\n`peek_result` doesn't help this situation. It gives you monotonically increasing coverage numbers that involves a lot of extra (error-prone) work to try to figure out what was actually walked over.\n", "created_at": "2016-10-07 21:59:34", "user": 9832, "id": 252371383}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252376796", "text": "> > However, I cannot understand how this patch addresses your problem. Even if we can reset the coverage status, we cannot avoid a fact that a common helper function are accidentally executed by another test.\n> \n> Can you explain the confusion further?\n\nI think what @mame is trying to say is: how does resetting the coverage information eliminate the \"false positives\" from your test?  The example program you show will still show that `Y#y` and `Z#z` were executed even though the class under test is `X`.\n\nMaybe showing the coverage that you _want_ for that test case would be helpful?\n", "created_at": "2016-10-07 22:32:46", "user": 3124, "id": 252376796}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252377274", "text": "> The example program you show will still show that Y#y and Z#z were executed even though the class under test is X.\n\nNo, that's what `peek_result` would show. My baseline (coverage after load, but w/o tests) would reset it back to as if it had just loaded. That way `X#x`, `Y#y`, and `Z#z` would all be back at zero. Then if `Z` or `Y` were actually tested, their numbers would speak for themselves. Repeat for all tests. The only thing I'm stuck with doing is trying to map TC to CUT.\n", "created_at": "2016-10-07 22:36:08", "user": 9832, "id": 252377274}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252378380", "text": "> No, that's what peek_result would show. My baseline (coverage after load, but w/o tests) would reset it back to as if it had just loaded.\n\nDoes this happen before `test_x` is run?\n\n> That way X#x, Y#y, and Z#z would all be back at zero. Then if Z or Y were actually tested, their numbers would speak for themselves.\n\nI guess I don't understand.  `X#x` calls `Y#y` which calls `Z#z`.  When `test_x` is run, how does \"resetting to 0\" avoid showing coverage for `Y#y` and `Z#z`?  Coverage counters for those lines will be increased (since they are executed).\n", "created_at": "2016-10-07 22:43:59", "user": 3124, "id": 252378380}, {"reactions": {"+1": [168854]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/252388354", "text": "If I understand this patch correctly, I think it could be implemented in terms of `peek_result` [like this](https://gist.github.com/tenderlove/9d8fb0a5a37c559236237b6e00b0d3a9). (Please note that I'm not saying my code is great, I'm trying to understand the situation)\n", "created_at": "2016-10-08 00:11:25", "user": 3124, "id": 252388354}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253668961", "text": "> I guess I don't understand. X#x calls Y#y which calls Z#z. When test_x is run, how does \"resetting to 0\" avoid showing coverage for Y#y and Z#z? Coverage counters for those lines will be increased (since they are executed).\n\nThey will be increased... and then on the next test they'll be thrown away when I reset to the baseline. I'll only record off the coverage for `X` when I'm running `TestX`. With `peek_result` (not resetting baseline) you'd keep getting monotonically increasing numbers, which are false positives.\n\nWith your patch, (I assume, I have yet to run it), you're subtracting `n - o`, which results in zeros for any lines that were covered in the baseline, resulting in false negatives. You could then take it a step further and record off YET ANOTHER thing to add back in... thus proving my argument that managing it myself it overly complex without much benefit.\n\nThis patch cleans stuff up on the client side dramatically and it _makes sense_. I'm simply resetting to baseline.\n", "created_at": "2016-10-13 23:27:40", "user": 9832, "id": 253668961}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253669217", "text": "I'm still in the proof-of-concept/prototype phase on my project, but I'm fairly certain this is the right way to do coverage analysis to avoid false positives.\n\nIt seems like I'm being challenged to have everything flushed out despite @mame's tweet:\n\n> @the_zenspider Will do the weekend. I think the API be minimal, but I'm not particular about the principle if that is really useful for you.\n\nThis is really useful to me. I've passed @nobu's scrutiny (THANK YOU @nobu, you always find things so quickly). Why is there this much pushback?\n\nIs there something I can better do to get this accepted?\n", "created_at": "2016-10-13 23:29:18", "user": 9832, "id": 253669217}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253756358", "text": "> With your patch, (I assume, I have yet to run it), you're subtracting n - o, which results in zeros for any lines that were covered in the baseline, resulting in false negatives. You could then take it a step further and record off YET ANOTHER thing to add back in... thus proving my argument that managing it myself it overly complex without much benefit.\n\nSo we agree that this could be implemented with `peek_result` it would just be not fun.\n\n> Is there something I can better do to get this accepted?\n\nI think a practical example (and a test) would go a long way.  It's hard to understand _why_ this is necessary, or _why_ using `peek_result` is hard without real code to experiment with.  I would like to _attack the problem_ but it's hard to understand the problem without code.\n\nThe only other concern I would have is:\n1. Do we care if two libraries are using `Coverage` at the same time? Mutating coverage info could mess up other tools\n2. Do we need to validate the input on `result=`? This patch lets you set arrays with arbitrary objects inside.\n\nMaybe we could wrap up the recording / diff logic in a new class and leave the monotonic, non-mutable implementation intact.\n", "created_at": "2016-10-14 09:47:14", "user": 3124, "id": 253756358}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253764987", "text": "> On Oct 14, 2016, at 02:47, Aaron Patterson notifications@github.com wrote:\n> \n> Maybe we could wrap up the recording / diff logic in a new class and leave the monotonic, non-mutable implementation intact.\n\nOr address the side-effect that this is really trying to bypass: that calling `result` effectively shuts down the whole thing permanently.\n", "created_at": "2016-10-14 10:28:41", "user": 9832, "id": 253764987}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253781735", "text": "> It seems like I'm being challenged to have everything flushed out despite @mame's tweet: [...]\n\nI think it's good to have something well fleshed-out for a new API. Because once it is in, it becomes incompatible to change it and might limit other usages.\n\nFor instance, changing `Coverage.result` is most likely unacceptable.\n\n> Why is there this much pushback?\n\nWe just want to understand what you need and the use case.\nIf `Coverage.result=` is a convenience method over `Coverage.peek_result`, it's of course reasonable to ask for inclusion, but it's not \"something that was not possible before\" as you present it on `minitest-coverage`:\n\n> Worse, the tracing facilities currently make it impossible to get truly accurate numbers.\n", "created_at": "2016-10-14 12:03:41", "user": 168854, "id": 253781735}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253807596", "text": "Thank you all for discussing this.\n\n> I'll only record off the coverage for X when I'm running TestX.\n\nYou mean that you will discard the coverage for Y and Z when you run TestX by using the naming convention or by using any external information from Coverage library?  If so, it makes sense.  (I don't know if it is a good idea, though.)\n\n> We just want to understand what you need and the use case.\n\nI agree with @eregon.  I'm okay if this proposal is actually useful for any reasonable use case, but we want to understand what use case it is useful for and how it is useful.\n\n> managing it myself it overly complex without much benefit.\n\nPlease note that Coverage is not a normal Ruby library.  Coverage API focuses on providing a minimal feature set to measure coverage information.  Keeping Coverage small is benefit (for me).  Usability is of secondary importance.\n\nI think you are creating a program to extract X's coverage for TestX.  I think it will involve a naming convention resolver (or external configuration file that maps from testing classes to tested classes) to identify what class is actually tested, and a Ruby parser to identify which lines of code belong to the tested class.  It looks a massive project.  Isn't calculating the difference of two `peek_result`s relatively easy?\n\nAlso, what I worry about the most is, that `Coverage.result=` is too strong just for the use case.  Is assigning arbitrary array to it really needed?  Are APIs like `Coverage.checkpoint` and `restore` enough?\n\n```\nCoverage.checkpoint # instead of: baseline = Coverage.peek_result\n....\nCoverage.restore    # instead of: Coverage.result = baseline\n```\n\nI have no confidence if this is good enough, but at least, it requires no validation (@tenderlove's Problem 2).  \n\nBTW, I personally don't care Problem 1 since `Coverage.result` won't work well in the situation.  I believe a sane person won't use multiple coverage measurement tools simultaneously.\n", "created_at": "2016-10-14 14:00:31", "user": 21557, "id": 253807596}, {"reactions": {"laugh": [3124, 8162268]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/253821919", "text": "> I believe a sane person won't use multiple coverage measurement tools simultaneously\n\nChallenge\u2026 accepted\n", "created_at": "2016-10-14 14:49:47", "user": 199, "id": 253821919}], "assignees": [21557, 21557], "state": "open", "is-pull-request": true}, "221820284": {"text": "Array#<=> will be ~7.5 times faster with Fixnum elements.\r\n\r\n* Before\r\n```\r\n               user     system      total        real\r\nFixnum     2.020000   0.010000   2.030000 (  2.022351)\r\nString     2.290000   0.000000   2.290000 (  2.289221)\r\n```\r\n\r\n* After\r\n```\r\n               user     system      total        real\r\nFixnum     0.260000   0.000000   0.260000 (  0.266339)\r\nString     0.520000   0.000000   0.520000 (  0.529152)\r\n```\r\n\r\n* Test code\r\n```\r\nrequire 'benchmark'\r\n\r\nBenchmark.bmbm do |x|\r\n\r\n  x.report \"Fixnum\" do\r\n    ary1 = Array.new(1000) { rand(1000) }\r\n    ary2 = ary1.dup\r\n\r\n    50000.times do\r\n      ary1 <=> ary2\r\n    end\r\n  end\r\n\r\n  x.report \"String\" do\r\n    ary1 = Array.new(1000) { rand(1000).to_s }\r\n    ary2 = ary1.dup\r\n\r\n    50000.times do\r\n      ary1 <=> ary2\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nhttps://bugs.ruby-lang.org/issues/13436", "labels": [], "number": 1583, "updated_at": "2018-02-23 03:07:34", "user": 199156, "closed_at": null, "id": 221820284, "title": "Improve performance of Array#<=> with Fixnum/String elements", "url": "https://api.github.com/repos/ruby/ruby/issues/1583", "created_at": "2017-04-14 14:31:15", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/302722770", "text": "I don't know this affects real world application's performance.", "created_at": "2017-05-19 14:46:32", "user": 13423, "id": 302722770}], "assignees": [], "state": "open", "is-pull-request": true}, "229827966": {"text": "The st_is_member DEFINE has simpler semantics, for more readable code.", "labels": [], "number": 1622, "updated_at": "2018-02-23 03:07:36", "user": 5470, "closed_at": null, "id": 229827966, "title": "Prefer st_is_member over st_lookup with 0", "url": "https://api.github.com/repos/ruby/ruby/issues/1622", "created_at": "2017-05-18 23:01:43", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "304815493": {"text": "Related to https://github.com/ruby/ruby/pull/1832, but this patch is just for a case `arg_check=true`.", "labels": [], "number": 1838, "updated_at": "2018-03-13 15:32:33", "user": 1716463, "closed_at": null, "id": 304815493, "title": "uri: do not use user/password/port with file", "url": "https://api.github.com/repos/ruby/ruby/issues/1838", "created_at": "2018-03-13 15:32:33", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "231892870": {"text": "I had to implement the following for some nicer methods in another instance where I'm using the code. It's my first Ruby PR so please let me know if I've messed anything up!\r\n\r\n```ruby\r\n  def get_ip\r\n    self.inspect.split(/[\\/:]/).slice(2)\r\n  end\r\n\r\n  def get_subnet\r\n    self.inspect.split(/[\\/:>]/).slice(3)\r\n  end\r\n```", "labels": [], "number": 1636, "updated_at": "2018-02-23 03:07:36", "user": 182765, "closed_at": null, "id": 231892870, "title": "IPAddr add helper commands get_ip and get_subnet", "url": "https://api.github.com/repos/ruby/ruby/issues/1636", "created_at": "2017-05-28 20:39:14", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/304544007", "text": "I'm a bit confused as to why the first CI build is failing, on my own machine it returns success:\r\n\r\n```travis\r\n$ make -s $JOBS test-rubyspec MSPECOPT=-j\r\ngenerating x86_64-linux-fake.rb\r\nIn file included from /usr/include/bits/libc-header-start.h:33:0,\r\n                 from /usr/include/stdio.h:28,\r\n                 from ../include/ruby/defines.h:101,\r\n                 from ../include/ruby/ruby.h:36,\r\n                 from ../version.c:12:\r\n/usr/include/features.h:373:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]\r\n #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)\r\n    ^~~~~~~\r\ncc1: warning: unrecognized command line option \u2018-Wno-self-assign\u2019\r\ncc1: warning: unrecognized command line option \u2018-Wno-constant-logical-operand\u2019\r\ncc1: warning: unrecognized command line option \u2018-Wno-parentheses-equality\u2019\r\nx86_64-linux-fake.rb updated\r\nruby 2.5.0dev (2017-05-29 ipaddr-get-sub.. 58948) [x86_64-linux]\r\n[- | ==================100%================== | 00:00:00]      0F      0E \r\n\r\nFinished in 20.919751 seconds\r\n\r\n3569 files, 26409 examples, 200760 expectations, 0 failures, 0 errors, 0 tagged\r\n```\r\n\r\nIf somebody could point me in the right direction I'd be grateful!", "created_at": "2017-05-28 22:19:44", "user": 182765, "id": 304544007}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/304548360", "text": "@x89 Can you rebase from our latest master?", "created_at": "2017-05-28 23:55:35", "user": 12301, "id": 304548360}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/304590983", "text": "@hsbt this was from the `trunk` branch, should I be using the `2.4` branch instead?", "created_at": "2017-05-29 07:20:52", "user": 182765, "id": 304590983}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/304644454", "text": "Okay it seems to have worked now, I created a bug report (feature request) as well https://bugs.ruby-lang.org/issues/13610", "created_at": "2017-05-29 12:00:04", "user": 182765, "id": 304644454}], "assignees": [10236, 10236], "state": "open", "is-pull-request": true}, "217802122": {"text": "Run this code (named as `test.rb`):\n```\nmodule Hoge\nend\n\nclass Foobar\nend\n\np Hoge.source_location\np Foobar.source_location\n```\n\nYou should got:\n```\n[\"./test.rb\", 1]\n[\"./test.rb\", 4]\n```\n\nPlease some comments.", "labels": [], "number": 1562, "updated_at": "2018-02-23 03:07:33", "user": 239637, "closed_at": null, "id": 217802122, "title": "Module#source_location, Class#source_location", "url": "https://api.github.com/repos/ruby/ruby/issues/1562", "created_at": "2017-03-29 08:33:17", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/290318963", "text": "Corresponds with this ticket: https://bugs.ruby-lang.org/issues/13383", "created_at": "2017-03-30 06:52:23", "user": 239637, "id": 290318963}], "assignees": [], "state": "open", "is-pull-request": true}, "174090130": {"text": "Instead, look for instance methods of Kernel.\nOtherwise, instance methods of Module (which are methods of Kernel\nitself) are mistakenly believed to exist, and it fails when calling\nKernel.instance_method().\n\n@nobu \n", "labels": [], "number": 1422, "updated_at": "2018-02-23 03:07:17", "user": 3535, "closed_at": null, "id": 174090130, "title": "delegate.rb: don't look for methods on Kernel", "url": "https://api.github.com/repos/ruby/ruby/issues/1422", "created_at": "2016-08-30 18:25:04", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "108492183": {"text": "For improve consistency with Module#define_method and Module#alias_method.\n\nticket: https://bugs.ruby-lang.org/issues/11554\n", "labels": [], "number": 1036, "updated_at": "2018-02-23 03:07:03", "user": 1180335, "closed_at": null, "id": 108492183, "title": "Privatize {Single}Forwardable API", "url": "https://api.github.com/repos/ruby/ruby/issues/1036", "created_at": "2015-09-26 19:59:06", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "250346394": {"text": "Improve performance of `Base64.urlsafe_encode64` by avoiding unnecessary memory allocations\r\n\r\nhttps://bugs.ruby-lang.org/issues/13827", "labels": ["Performance"], "number": 1676, "updated_at": "2018-02-23 03:07:37", "user": 1593860, "closed_at": null, "id": 250346394, "title": "Improve performance of Base64.urlsafe_encode64", "url": "https://api.github.com/repos/ruby/ruby/issues/1676", "created_at": "2017-08-15 15:18:24", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/322512505", "text": "@soylent Thank you for your PR. While this change will reduce string allocations for sure, I'm not sure how much this would help improve performance in a real-world application. Do you have any realistic benchmark script?", "created_at": "2017-08-15 16:09:18", "user": 386234, "id": 322512505}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/322528036", "text": "I've been profiling a web service that I'm working on, and this patch makes a noticible improvement. Here are excerpts from the profiler reports.\r\n\r\nBefore\r\n\r\n```\r\nallocated memory by file\r\n-----------------------------------\r\n     13036  /Users/x/.rbenv/versions/2.4.0/lib/ruby/2.4.0/base64.rb\r\n...\r\n```\r\n\r\nAfter\r\n\r\n```\r\nallocated memory by file\r\n-----------------------------------\r\n      9152  /Users/x/.rbenv/versions/2.4.0/lib/ruby/2.4.0/base64.rb\r\n```\r\n\r\n30 % improvement", "created_at": "2017-08-15 17:09:22", "user": 1593860, "id": 322528036}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/322529687", "text": "Could you share the entire benchmark script? It's impossible to judge without looking at actual benchmark scripts since that 30% improvement could only be 0.1% (or even less) of the whole memory allocation for a typical web operation.", "created_at": "2017-08-15 17:15:52", "user": 386234, "id": 322529687}, {"reactions": {"+1": [323891, 13723, 4083992]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/322724789", "text": "In case of the web service I am working on this patch reduces the overall amount of memory allocated per request by 1.8 %. There are about 0.5-1M such requests every day. Unfortunately, I cannot share the source code of the service, and not sure what a typical web operation is.\r\n\r\nBut my point is to avoid creating garbage objects and reduce the GC time. Here is a simple benchmark\r\n\r\n```ruby\r\nrequire 'benchmark/ips'\r\nrequire 'base64'\r\nrequire 'securerandom'\r\n\r\nBenchmark.ips do |x|\r\n  string = SecureRandom.bytes(128)\r\n\r\n  x.report 'Base64.urlsafe_encode64' do |t|\r\n    t.times { Base64.urlsafe_encode64(string) }\r\n  end\r\nend\r\n```\r\n\r\nBefore\r\n\r\n```\r\nCalculating -------------------------------------                                         \r\nBase64.urlsafe_encode64                                                                   \r\n                        559.355k (\u00b1 3.2%) i/s -      2.805M in   5.019239s                \r\n```\r\n\r\nAfter\r\n\r\n```                      \r\nCalculating -------------------------------------\r\nBase64.urlsafe_encode64\r\n                        736.211k (\u00b1 2.5%) i/s -      3.721M in   5.057606s\r\n```\r\n\r\nI think, the results are good for such easy and trivial change.", "created_at": "2017-08-16 10:04:47", "user": 1593860, "id": 322724789}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/322811602", "text": "Thanks for explaining, I'm convinced.\r\n\r\n@ko1 @nobu do you have any objections?", "created_at": "2017-08-16 15:37:05", "user": 386234, "id": 322811602}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/322847066", "text": "It may help to also file an issue at https://bugs.ruby-lang.org/projects/ruby-trunk/issues?set_filter=1&tracker_id=2 or similar; it makes tracking easier and I think nobu likes to keep numbers assigned to changes to the ruby source via the official tracker at bugs.ruby-lang.org.", "created_at": "2017-08-16 17:44:27", "user": 13723, "id": 322847066}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/323324947", "text": "@shevegen Thanks, I've added a link to the issue in Redmine in the description.", "created_at": "2017-08-18 11:01:50", "user": 1593860, "id": 323324947}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/323810191", "text": "Let me briefly +1 the need for this improvement: Web applications are converging on base64url for moving binary data in JSON (e.g., see JWT), so this is increasingly performance-relevant.\r\n", "created_at": "2017-08-21 17:56:57", "user": 23118, "id": 323810191}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/323813928", "text": "Please don't +1. We are aware of this request and going to merge this before the release of 2.5.0. Thanks for your patience!", "created_at": "2017-08-21 18:10:03", "user": 386234, "id": 323813928}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/323919324", "text": "This could be even better.  Same-ish when padding is true, ~1.50x faster when padding is false.\r\n```ruby\r\n       if padding\r\n         str.tr!(\"+/\", \"-_\")\r\n       else\r\n         str.tr!(\"+/=\", \"-_\")\r\n       end\r\n```", "created_at": "2017-08-22 04:58:23", "user": 10236, "id": 323919324}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/323929329", "text": "Oops, I was misunderstanding something, and didn't notice this issue was locked.  Please ignore my previous bogus comment.", "created_at": "2017-08-22 06:13:54", "user": 10236, "id": 323929329}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/323930509", "text": "> This could be even better. Same-ish when padding is true, ~1.50x faster when padding is false.\r\n\r\n\u2764\ufe0f ", "created_at": "2017-08-22 06:20:36", "user": 11493, "id": 323930509}], "assignees": [386234, 386234], "state": "open", "is-pull-request": true}, "116971941": {"text": "These method allow us to get visibility from `Method` and\n`UnboundMethod` object.\n", "labels": [], "number": 1098, "updated_at": "2018-02-23 03:07:05", "user": 5356517, "closed_at": null, "id": 116971941, "title": "Add `Method#visibility` and `UnboundMethod#visibility`", "url": "https://api.github.com/repos/ruby/ruby/issues/1098", "created_at": "2015-11-15 04:20:13", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/156780363", "text": "ticket https://redmine.ruby-lang.org/issues/11689\n", "created_at": "2015-11-15 04:53:59", "user": 5356517, "id": 156780363}], "assignees": [], "state": "open", "is-pull-request": true}, "269141424": {"text": "Add two methods (\u201cantisymmetric?\u201d and \u201creflexive?\u201d) determine if the\nmatrix is reflexive, antisymmetric or not.", "labels": [], "number": 1730, "updated_at": "2018-02-23 03:07:39", "user": 5194080, "closed_at": null, "id": 269141424, "title": "Add Matrix#antisymmetric? and Matrix#reflexive?", "url": "https://api.github.com/repos/ruby/ruby/issues/1730", "created_at": "2017-10-27 15:14:34", "comments": [{"reactions": {"+1": [5194080]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/351625474", "text": "Thanks for the PR.\r\nThese look like valid additions to the library.\r\nThe PR some issues though:\r\n\r\n* needs specs, ideally in `ruby/spec/library/matrix/\r\n* the code for antisymmetric looks wrong\r\n* would probably be nicer to use `all?` instead of the `return true/false`\r\n\r\nWould you like to amend your PR?", "created_at": "2017-12-14 06:59:07", "user": 33770, "id": 351625474}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/354118805", "text": "and: antisymmetric_spec.rb is not in the correct directory", "created_at": "2017-12-27 14:07:13", "user": 1112299, "id": 354118805}], "assignees": [33770, 33770], "state": "open", "is-pull-request": true}, "211955123": {"text": "This introduce shortcut to call Array#== and Hash#== then improve these methods performance around 5%.\r\n\r\n### Before\r\n```\r\n               user     system      total        real\r\nHash#==    0.850000   0.000000   0.850000 (  0.853143)\r\nArray#==   0.650000   0.010000   0.660000 (  0.654546)\r\n```\r\n\r\n### After\r\n```\r\nHash#==    0.800000   0.000000   0.800000 (  0.803759)\r\nArray#==   0.610000   0.000000   0.610000 (  0.606047)\r\n```\r\n\r\n### Test code\r\n```\r\nrequire 'benchmark'\r\n\r\nBenchmark.bmbm do |x|\r\n  $hash1 = {}\r\n  1000.times { |i| $hash1[i.to_s] = i }\r\n  $hash2 = {}\r\n  1000.times { |i| $hash2[(i*2).to_s] = i*2 }\r\n\r\n  x.report \"Hash#==\" do\r\n    2000000.times do\r\n      $hash1 == $hash2\r\n    end\r\n  end\r\n\r\n  $ary1 = []\r\n  1000.times { |i| $ary1 << i }\r\n  $ary2 = []\r\n  1000.times { |i| $ary2 << i*2 }\r\n\r\n  x.report \"Array#==\" do\r\n    2000000.times do\r\n      $ary1 == $ary2\r\n    end\r\n  end\r\nend\r\n```", "labels": [], "number": 1530, "updated_at": "2018-02-23 03:07:30", "user": 199156, "closed_at": null, "id": 211955123, "title": "Improve Array#== and Hash#== performance", "url": "https://api.github.com/repos/ruby/ruby/issues/1530", "created_at": "2017-03-05 14:11:28", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "222614969": {"text": "\"set instance variable\" will be faster around 14%.\r\n\r\n## macOS 10.12 + clang-802.0.41\r\n* Before\r\n```\r\n       user     system      total        real\r\n   1.550000   0.000000   1.550000 (  1.555161)\r\n```\r\n\r\n* After\r\n```\r\n       user     system      total        real\r\n   1.400000   0.000000   1.400000 (  1.398825)\r\n```\r\n\r\n## macOS 10.12 + gcc 6.3.0_1\r\n* Before\r\n```\r\n       user     system      total        real\r\n   1.660000   0.000000   1.660000 (  1.659721)\r\n```\r\n\r\n* After\r\n```\r\n       user     system      total        real\r\n   1.450000   0.000000   1.450000 (  1.454589)\r\n```\r\n\r\n## Ubuntu 16.04 + gcc 5.4.0\r\n* Before\r\n```\r\n       user     system      total        real\r\n   0.890000   0.000000   0.890000 (  0.891217)\r\n```\r\n\r\n* After\r\n```\r\n       user     system      total        real\r\n   0.790000   0.000000   0.790000 (  0.783157)\r\n```\r\n\r\n## Test code\r\n```\r\nrequire 'benchmark'\r\n\r\nBenchmark.bmbm do |x|\r\n  x.report do\r\n    i = 0\r\n    while (i < 50000000)\r\n      @obj = 42\r\n      i+=1\r\n    end\r\n  end\r\n\r\nend\r\n```\r\n\r\nhttps://bugs.ruby-lang.org/issues/13482", "labels": [], "number": 1590, "updated_at": "2018-02-23 03:07:34", "user": 199156, "closed_at": null, "id": 222614969, "title": "Improve performance of \"set instance variable\"", "url": "https://api.github.com/repos/ruby/ruby/issues/1590", "created_at": "2017-04-19 04:29:48", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "190452156": {"text": "The main reason why I absolutely appreciate Ruby programming language is because operators are ubiquitous among the syntax. That's why I think that be able to merge hashes with the + operator would be extremely cool.\r\n\r\nI thought to contribute that patch while doing something I thought was not homogenous throught the syntax. It this case it was a Redmine plugin. For instance :\r\n\r\n```ruby\r\ndef self.fetch_and_summation(scope, extra_conditional)\r\n\r\n    in_trackers = {:tracker => {:is_closed => false}}\r\n    in_scope = {(scope.class.name.downcase.to_sym) => scope}\r\n    # [...]\u00a0Many more others conditionals similar to those\r\n\r\n    stuff[:estimated_hours] = Issue.where(in_trackers.merge(in_scope).[...]).group(:category).sum([...])[...]\r\n    # [...] Many more others queries similar to this\r\n\r\n    return stuff;\r\n\r\nend\r\n```\r\nUsing `k1.merge(k2).merge(k3)` seems very scary compared to the rest of source code.\r\n\r\nWith that patch it would look like more like this :\r\n```ruby\r\nstuff[:estimated_hours] = Issue.where(in_tracker + in_scope + extra_conditional + [...])\r\n```\r\n\r\nIt is ultra sexy isn't it ? It works directly from an alias of the blessed core Hash.merge method.", "labels": [], "number": 1487, "updated_at": "2018-02-23 03:07:24", "user": 4608579, "closed_at": null, "id": 190452156, "title": "Permit \"+\" operator as an alias to merge hashes", "url": "https://api.github.com/repos/ruby/ruby/issues/1487", "created_at": "2016-11-19 00:15:46", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/261926807", "text": "Rails 3.0 only had `#&` alias for `#merge`, but removed. http://apidock.com/rails/v3.0.9/ActiveRecord/SpawnMethods/%26", "created_at": "2016-11-21 12:42:39", "user": 11857, "id": 261926807}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/261958296", "text": "Interesting, why they removed such a functionality ? That patch is meant for the Ruby Lang; Rails was used for example purposes.", "created_at": "2016-11-21 14:50:35", "user": 4608579, "id": 261958296}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/261997671", "text": "I don't know why removed, because [removed commit](https://github.com/rails/rails/commit/fbd917f50a6046d02dd6a64ccfb1aed0cbce68d8) and [deprecated commit](https://github.com/rails/rails/commit/66003f596452aba927312c4218dfc8d408166d54) have no references.", "created_at": "2016-11-21 16:56:04", "user": 11857, "id": 261997671}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/262208346", "text": "It looks pretty much like a duplicate of  #1359 to me", "created_at": "2016-11-22 10:48:35", "user": 2010013, "id": 262208346}], "assignees": [], "state": "open", "is-pull-request": true}, "188963271": {"text": "net/http, net/pop, net/smtp and net/ftp use `Timeout.timeout` to calculate connect_timeout.\r\nTimeout.timeout is slow. It creates and destroys a thread every time.\r\nTimeout.timeout is also dangerous. see [Timeout: Ruby's Most Dangerous API](http://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/)\r\n\r\nIt is more effective and safe to use socket timeout to accomplish that. \r\nFollow is the changes need to do.\r\n1. Replace `TCPSocket.open` with `Socket.tcp`\r\n2. Create `TCPSocket` with `TCPSocket.for_fd`\r\n\r\nredmine issue is here:\r\n[Use socket timeout for net/http and net/pop for open_timeout](https://bugs.ruby-lang.org/issues/12928)", "labels": [], "number": 1480, "updated_at": "2018-02-23 03:07:23", "user": 778284, "closed_at": null, "id": 188963271, "title": "Fast and safe connect timeout for net", "url": "https://api.github.com/repos/ruby/ruby/issues/1480", "created_at": "2016-11-13 10:30:54", "comments": [{"reactions": {"+1": [778284]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/260292115", "text": "Maybe what you need is `Socket.tcp` but returns `TCPSocket` instead of `Socket`.\n", "created_at": "2016-11-14 09:51:36", "user": 16700, "id": 260292115}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/260294257", "text": "Good idea. I don't know `Socket.tcp` supports connect_timeout before. I will change it. Thank you.\n", "created_at": "2016-11-14 10:01:09", "user": 778284, "id": 260294257}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/260397517", "text": "I use `Socket.tcp` now. `Socket.tcp` returns `Socket` instance. So I need to convert it to `TCPSocket` instance using `TCPSocket.for_fd`. And I apply it for net/smtp and net/ftp also.\nThank you for your advice. @nobu \n", "created_at": "2016-11-14 17:12:09", "user": 778284, "id": 260397517}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/260553623", "text": "Socket.tcp is designed to replace TCPSocket, so it's better to use Socket itself.\n", "created_at": "2016-11-15 05:50:03", "user": 34552, "id": 260553623}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/260557672", "text": "Replaced `addr` and `peeraddr` with modern `Addrinfo` interfaces, and all tests would pass without `for_fd` hack.\n", "created_at": "2016-11-15 06:21:10", "user": 16700, "id": 260557672}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/260716523", "text": "I changed the codes. Removed TCPSocket.for_fd and used socket directly now.\n", "created_at": "2016-11-15 17:58:23", "user": 778284, "id": 260716523}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/260718580", "text": "Eric Wong Post:\n\n>  I agree with eliminating Timeout, but I don't think your\n> solution is enough because it does not cover timeouts for\n> DNS resolution (getaddrinfo(3) calls).\n> \n> For timeouts, we would need to use resolv.rb instead of getaddrinfo(3)\n> provided by libc to do timeouts without a separate thread. I started\n> adding timeouts to resolv.rb last year but can't remember how far I got...\n> I'm not sure if resolv.rb supports all the features of a modern\n> getaddrinfo(3), either, AFAIK, not many people use resolv.rb.\n\nI need to fix it.\n", "created_at": "2016-11-15 18:06:15", "user": 778284, "id": 260718580}], "assignees": [], "state": "open", "is-pull-request": true}, "278520265": {"text": "Currently we are not able to grab the correct end/top of the stack on\r\npowerpc64 due to the fact that it uses the fallback function.\r\n\r\nThe fallback function does not return the correct top of the stack\r\nbecause it adds a new frame and the returned top of the stack contains\r\nthis frame overhead that could be something around 112 bytes on\r\nPowerpc64.\r\n\r\nThis patch simply gets the correct top of the stack pointer, which is\r\nalways on r1 register according to both ABI v1 and ABI v2 (Little\r\nendian).\r\n\r\nSigned-off-by: Breno Leitao <leitao@debian.org>", "labels": [], "number": 1767, "updated_at": "2018-02-23 03:07:42", "user": 148379, "closed_at": null, "id": 278520265, "title": "gc.h: Add SET_MACHINE_STACK_END specific for Powerpc64", "url": "https://api.github.com/repos/ruby/ruby/issues/1767", "created_at": "2017-12-01 16:25:43", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "233316810": {"text": "In our codebase we have a few instances where we need, for a variety of reasons, to monkey patch a class. With the advent of `Module#prepend`, this is now much cleaner and safer than the days of `alias_method_chain` from Rails or carefully aliasing and calling the original in plain ruby. \r\n\r\nWe have a pattern when we do these kinds of things that look like this:\r\n\r\n```ruby\r\nModule.new do\r\n  def some_original_method\r\n    do_something_else\r\n    super\r\n  end\r\nend.tap { |mod| OriginalClass.prepend(mod) }\r\n```\r\n\r\nThis works great, but it's not the nicest syntax. It would be really nice if you could just pass a block directly to `Module#prepend` that's what this PR does. This would allow one to rewrite the snippet above more like this:\r\n\r\n```ruby\r\nOriginalClass.prepend do\r\n  def some_original_method\r\n    do_something_else\r\n    super\r\n  end\r\nend\r\n```", "labels": [], "number": 1639, "updated_at": "2018-02-23 03:07:36", "user": 242, "closed_at": null, "id": 233316810, "title": "Make Module#prepend take a block", "url": "https://api.github.com/repos/ruby/ruby/issues/1639", "created_at": "2017-06-02 22:22:43", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/305935380", "text": "You can write the former without `tap`.\r\n\r\n```ruby\r\nOriginalClass.prepend Module.new {\r\n  def some_original_method\r\n    do_something_else\r\n    super\r\n  end\r\n}\r\n```", "created_at": "2017-06-03 00:09:00", "user": 16700, "id": 305935380}], "assignees": [], "state": "open", "is-pull-request": true}, "198140885": {"text": "This is an accurate (as possible) fdiv implementation for Fixnum and Bignum.", "labels": [], "number": 1508, "updated_at": "2018-02-23 03:07:27", "user": 231367, "closed_at": null, "id": 198140885, "title": "accurate (as possible) fdiv for Fixnum and Bignum", "url": "https://api.github.com/repos/ruby/ruby/issues/1508", "created_at": "2016-12-30 12:16:53", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/269937609", "text": "Do you have an example that the result changes, or a test case in other words?", "created_at": "2017-01-02 06:24:34", "user": 16700, "id": 269937609}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/269945852", "text": "A Fixnum example is,\r\n~~~\r\n  $ ruby24 --disable=gems -e 'print \"%a\\n\" % [2319276427521816828.fdiv(3325853508004318597)]'\r\n  0x1.650ac352d9ccp-1\r\n  $ ./miniruby -v --disable=gems -e 'print \"%a\\n\" % [2319276427521816828.fdiv(3325853508004318597)]'\r\n  ruby 2.5.0dev (2016-12-30) [x86_64-freebsd10.3]  <== (my patched version)\r\n  0x1.650ac352d9cc1p-1\r\n~~~\r\n\uff08due to 2319276427521816828/3325853508004318597r is irreducible, this pattern didn't affect by reducing \uff09", "created_at": "2017-01-02 08:49:50", "user": 231367, "id": 269945852}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/270068534", "text": "Current trunk is:\r\n\r\n```\r\n$ ruby -v -e 'x=2319276427521816828; y=3325853508004318597; z=x.fdiv(y)*y; p z, z-x'\r\nruby 2.5.0dev (2017-01-01 trunk 57245) [universal.x86_64-darwin15]\r\n2.3192764275218166e+18\r\n0.0\r\n```\r\n\r\nbut yours is:\r\n\r\n```\r\n$ ./ruby -e 'x=2319276427521816828; y=3325853508004318597; z=x.fdiv(y)*y; p z, z-x'\r\n2.319276427521817e+18\r\n512.0\r\n```", "created_at": "2017-01-03 08:31:16", "user": 16700, "id": 270068534}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/270072944", "text": "HMM, but it is correctly rounded value as below. I'm thinking more better demonstration...\r\n~~~\r\n$ cat sample.rb\r\nx=2319276427521816828\r\ny=3325853508004318597\r\nprint \"%a\\n\" % [2319276427521816828.fdiv(y)]\r\nprint \"%x\\n\" % [(x<<57)/y]\r\n$ ./miniruby sample.rb (this miniruby is my version)\r\n0x1.650ac352d9cc1p-1\r\n1650ac352d9cc0a\r\n~~~", "created_at": "2017-01-03 09:06:41", "user": 231367, "id": 270072944}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/272083890", "text": "I've found more demonstrable edge case.\r\n~~~\r\n$ cat fdiv_edgecase.rb\r\n#\r\nrequire 'bigdecimal'\r\n\r\nstrx = '66767141308812624791109361755796'\r\nstry = '17022200380664065'\r\n\r\nbdx = BigDecimal(strx)\r\nbdy = BigDecimal(stry)\r\nprint \"#{(bdx/bdy).to_s('f')}\\n\"\r\n\r\nx = strx.to_i\r\ny = stry.to_i\r\nprint \"%f\\n\" % [x.fdiv(y)]\r\n\r\n$ ../ruby-trunk -v fdiv_edgecase.rb\r\nruby 2.5.0dev (2017-01-11 trunk 57302) [x86_64-freebsd10.3]\r\n3922356676323412.249999999999999985313297082086923792468241814443649323\r\n3922356676323412.500000\r\n\r\n$ ../ruby fdiv_edgecase.rb # (mine)\r\n3922356676323412.249999999999999985313297082086923792468241814443649323\r\n3922356676323412.000000\r\n~~~\r\nHow is this ?", "created_at": "2017-01-12 06:04:09", "user": 231367, "id": 272083890}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/275887729", "text": "Also in that case, `x.fdiv(y)*y` will not equal to `x` while currently does.\r\nMaybe related to denormalization?", "created_at": "2017-01-29 01:38:34", "user": 16700, "id": 275887729}], "assignees": [], "state": "open", "is-pull-request": true}, "179106775": {"text": "Take this script for example:\n\n``` ruby\nGC.disable\n\nclass Foo\n  def exists?; end\n  def empty?; end\nend\n\ndef main\n  foo = Foo.new\n  puts foo.inspect\n  foo.exists?\nend\n\nmain\n\nGC.enable\nGC.start(full_mark: true, immediate_sweep: true)\n\nrequire 'objspace'\nputs ObjectSpace.each_object(Foo).to_a.first.inspect\n```\n\nExpected output:\n\n```\n#<Foo:0x00563762229c10>\nnil\n```\n\nActual output:\n\n```\n#<Foo:0x00563762229c10>\n#<Foo:0x00563762229c10>\n```\n\nBecause calling `empty?` is translated into a specific instruction (`opt_empty_p`), the receiver `foo` can still be referenced on the machine stack through `calling.recv`, assuming all calls happen in a single `vm_exec_core` call. That's why calling `exists?` instead of `empty?` works as expected because it's translated into the generic instruction `opt_send_without_block`, so calling `GC.start` or `GC.enable`) should override the value of `calling.recv`.\n", "labels": [], "number": 1447, "updated_at": "2018-02-23 03:07:19", "user": 1060507, "closed_at": null, "id": 179106775, "title": "Clear calling.recv after method calling to avoid marking it as accessible from machine context", "url": "https://api.github.com/repos/ruby/ruby/issues/1447", "created_at": "2016-09-25 20:22:06", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/249450431", "text": "Interesting. The problem of this patch is 0-clear cost for every calling. Did you check it?\n", "created_at": "2016-09-25 22:22:02", "user": 9558, "id": 249450431}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/249644981", "text": "@ko1 I ran this benchmark: `make benchmark OPTS=\"--pattern=vm2_method\" COMPARE_RUBY=\"ruby-without-fix::/opt/ruby-custom/bin/ruby\"` and this was the [output](https://gist.github.com/ahmadsherif/839cfdf706911192c55fa2253677968c).\n", "created_at": "2016-09-26 17:52:47", "user": 1060507, "id": 249644981}], "assignees": [], "state": "open", "is-pull-request": true}, "307223077": {"text": "Hello\r\n\r\nAfter reading https://bugs.ruby-lang.org/issues/14559 I thought it could be a good idea to try to implement this during the RubyHackChallenge at Cookpad office in Bristol. \r\n\r\nHere is my first PR for MRI, feel free to make any comments.\r\nI don't know if I need to add entry changelog somewhere.\r\n\r\nThanks @mame for the help when I was working on.", "labels": [], "number": 1844, "updated_at": "2018-03-21 18:03:25", "user": 8417720, "closed_at": null, "id": 307223077, "title": "Add slice method to ENV like Hash#slice", "url": "https://api.github.com/repos/ruby/ruby/issues/1844", "created_at": "2018-03-21 12:23:26", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/374993402", "text": "Could you adjust the indent?", "created_at": "2018-03-21 15:59:21", "user": 16700, "id": 374993402}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/375041017", "text": "Sorry. Is it better now @nobu ?\r\n\r\nThanks for the review", "created_at": "2018-03-21 18:03:25", "user": 8417720, "id": 375041017}], "assignees": [], "state": "open", "is-pull-request": true}, "155776165": {"text": "This allows for:\n\n``` ruby\nirb(main)> {a: 1} + {b: 2} + {c: 3}\n=> {:a=>1, :b=>2, :c=>3}\n```\n\nThis is very useful when composing a bigger hash, i.e.: mapping an object.\n", "labels": [], "number": 1359, "updated_at": "2018-02-23 03:07:12", "user": 8156, "closed_at": null, "id": 155776165, "title": "Add `+` operator to Hash as merge alias", "url": "https://api.github.com/repos/ruby/ruby/issues/1359", "created_at": "2016-05-19 16:10:41", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/220375840", "text": "Is there any particular reason for not having a `+` operator with that semantics in a Hash? It actually feels very natural to me to expect such behavior... Take an Array for instance:\n\n```\n[1, 2] + [3, 4]\n=> [1, 2, 3, 4]\n```\n", "created_at": "2016-05-19 16:17:43", "user": 508128, "id": 220375840}, {"reactions": {"+1": [8156, 9497, 7096667, 9787009, 4822049]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/220439914", "text": "I am neither a maintainer nor any other kind of authority, so feel free to disregard the following, but I suspect the reason is that a merge is not always an addition.\n\nIf I want to add a second array to an existing array, and the two have a non-empty intersection of elements, the result is well-defined:\n\n``` ruby\n[1, 2, 3] + [3, 4, 5]\n=> [1, 2, 3, 3, 4, 5]\n```\n\nWith two hashes whose intersection of keys is not empty, things aren\u2019t so clear-cut. What should the following produce?\n\n``` ruby\n{a: 1, b: 2} + {b: 3, c: 4}\n```\n\nThe default, in `merge`, is for the second instance of `:b` to clobber the former, so:\n\n``` ruby\n=> {:a =>1, :b => 3, :c => 4 }\n```\n\nThat\u2019s fine, but it means that the result isn\u2019t really an addition. I think that preserving the distinction between addition and merging is useful, especially since an explicit `merge` lets you provide a block with which to resolve collisions as circumstances warrant. YMMV, of course.\n", "created_at": "2016-05-19 20:18:08", "user": 1063575, "id": 220439914}, {"reactions": {"+1": [8156]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/220450130", "text": "Very good points @hivehand. On a second thought addition and merge are indeed two distinct operations.\n", "created_at": "2016-05-19 20:58:16", "user": 508128, "id": 220450130}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/222283006", "text": "Please submit your proposal to our tracker ( https://bugs.ruby-lang.org/issues/ ) for new feature.  We need to matz approval.\n", "created_at": "2016-05-28 01:28:40", "user": 12301, "id": 222283006}, {"reactions": {"hooray": [508128]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/222290120", "text": "I believe there's already a feature request for this behavior\n", "created_at": "2016-05-28 04:50:40", "user": 277819, "id": 222290120}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/228263857", "text": "@zzak No, We need to get approve from Matz on redmine tracker.\n", "created_at": "2016-06-24 05:53:45", "user": 12301, "id": 228263857}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/228287532", "text": "@hsbt I mean, there is already a ticket for this right?\n", "created_at": "2016-06-24 08:28:18", "user": 277819, "id": 228287532}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/228380597", "text": "This is the feature request. Other operators are discussed there: https://bugs.ruby-lang.org/issues/6225\n", "created_at": "2016-06-24 15:42:29", "user": 8156, "id": 228380597}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/228577577", "text": "@zzak We only accept feature request of core class like `Hash` on redmine tracker. not github's one.\n\n@xjunior Please create issue ticket to redmine tracker, if you hope to add this function to ruby core. We never merge this without Matz approval.\n", "created_at": "2016-06-26 00:33:29", "user": 12301, "id": 228577577}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/228578540", "text": "Would that work if I link this PR to that issue or does it have to be a new\none?\nOn Sat, Jun 25, 2016 at 9:34 PM SHIBATA Hiroshi notifications@github.com\nwrote:\n\n> @zzak https://github.com/zzak We only accept feature request of core\n> class like Hash on redmine tracker. not github's one.\n> \n> @xjunior https://github.com/xjunior Please create issue ticket to\n> redmine tracker, if you hope to add this function to ruby core. We never\n> merge this without Matz approval.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly, view it on GitHub\n> https://github.com/ruby/ruby/pull/1359#issuecomment-228577577, or mute\n> the thread\n> https://github.com/notifications/unsubscribe/AAAf3EUlKnKUHAPdF6JLFaLvDrNr7AEYks5qPckAgaJpZM4IibIB\n> .\n", "created_at": "2016-06-26 01:06:55", "user": 8156, "id": 228578540}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/228582218", "text": "@hsbt Ahh yeah, I meant [this ticket](https://bugs.ruby-lang.org/issues/6225) that @xjunior mentioned.\n\nIt looks like matz already rejected this request, so we should close this one?\n\nIf they want to try to change matz mind they should propose a new ticket which resolves his concerns about hash collision.\n", "created_at": "2016-06-26 03:29:07", "user": 277819, "id": 228582218}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/262256596", "text": "Do you think that throwing an exception if there's a collision would be a good solution to implement so it would be accepted ?", "created_at": "2016-11-22 14:36:44", "user": 4608579, "id": 262256596}, {"reactions": {"+1": [4608579, 509611]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/262331361", "text": "You will need to propose it to matz on the redmine tracker", "created_at": "2016-11-22 18:56:05", "user": 9831, "id": 262331361}], "assignees": [], "state": "open", "is-pull-request": true}, "109249508": {"text": "", "labels": [], "number": 1040, "updated_at": "2018-02-23 03:07:04", "user": 8188636, "closed_at": null, "id": 109249508, "title": "Just a little refactoring", "url": "https://api.github.com/repos/ruby/ruby/issues/1040", "created_at": "2015-10-01 08:06:59", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/144766650", "text": "After `vm_pop_frame()`, `*reg_cfp` may be invalid.\nIt must be like:\n\n``` c\n    finished = VM_FRAME_TYPE_FINISH_P(GET_CFP());\n    vm_pop_frame(th);\n    if (UNLIKELY(finished)) {\n```\n\nI'm afraid the current code is simple enough.\n", "created_at": "2015-10-01 15:43:14", "user": 16700, "id": 144766650}], "assignees": [], "state": "open", "is-pull-request": true}, "204585556": {"text": "add to_i method to TrueClass and FalseClass object\r\n\r\n", "labels": [], "number": 1523, "updated_at": "2018-02-23 03:07:29", "user": 48430, "closed_at": null, "id": 204585556, "title": "add to_i method to TrueClass and FalseClass object", "url": "https://api.github.com/repos/ruby/ruby/issues/1523", "created_at": "2017-02-01 13:37:30", "comments": [{"reactions": {"+1": [10193979], "laugh": [10193979]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276659444", "text": "Maybe we could set the constants in a separate header file ?", "created_at": "2017-02-01 13:41:10", "user": 2952153, "id": 276659444}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276659902", "text": "Could you please justify this?", "created_at": "2017-02-01 13:43:13", "user": 14068, "id": 276659902}, {"reactions": {"+1": [2480, 205357, 319081]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276701600", "text": "I only recently began following this repository. I am accustomed to changes being discussed at https://bugs.ruby-lang.org, so please excuse my ignorance of the process here.\r\n\r\nhttps://bugs.ruby-lang.org/projects/ruby/wiki/HowToContribute says:\r\n> Pull request to https://github.com/ruby/ruby is acceptable for tiny fixes. But pull requests which need discussions will be simply ignored.\r\n\r\nI suspect the Ruby maintainers would want to discuss whether `true` and `false` have a `to_i` method. I also think adding that method requires some justification. (Ruby has been ok for a long time without it.)", "created_at": "2017-02-01 16:16:49", "user": 14068, "id": 276701600}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276732125", "text": "This seems like bloat to me, solving a very specific problem in a very general way. You're assuming `true` means `1` for any Ruby code. If `true` means `1` for your project, define such a mapping in that particular project. And definitely not at the boolean-class level (`{True,False}Class#to_i`) but rather something like a simple Hash (`{true => 1, false => 0}`) more or less global (constant > ivar > local) depending on the scope.", "created_at": "2017-02-01 18:02:00", "user": 2480, "id": 276732125}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276737809", "text": "Here's another technique:\r\n\r\n```ruby\r\npry> BOOL = [false, true].freeze\r\n[\r\n    [0] false,\r\n    [1] true\r\n]\r\npry> BOOL.index(false)\r\n0\r\npry> BOOL.index(true)\r\n1\r\n```", "created_at": "2017-02-01 18:23:10", "user": 14068, "id": 276737809}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276740188", "text": "You'll need to address the conflict this pull request has with the existing behavior:\r\n\r\n```\r\n$ ruby -e 'if 0 then puts true else puts false end'\r\ntrue\r\n$ ruby -e 'if 1 then puts true else puts false end'\r\ntrue\r\n```\r\n\r\nIn your https://bugs.ruby-lang.org feature request.", "created_at": "2017-02-01 18:32:00", "user": 9831, "id": 276740188}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276751630", "text": "@drbrain Don't see any behaviour conflict there:\r\n> `$ ruby -e 'if 0 then puts true else puts false end'`\r\n\r\nYou seem to imply that any value returned by a method of `false` should also evaluate to false to avoid confusion \ud83e\udd14\r\n\r\nEven if this PR was merged, the fact that zero still evaluates to true (being non-nil, non-false) seems natural to me.\r\n\r\nJust like `false.to_s` evaluates to true:\r\n```ruby\r\nif false.to_s then p :ok end   # prints :ok\r\n```", "created_at": "2017-02-01 19:13:52", "user": 2480, "id": 276751630}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276752822", "text": "Haha. I\u2019m honored by the attention of this commit! \r\n\r\nMany times in my work I was calling for such conversion because I need to insert a boolean equation in an integer calculation for sorting collection or naming element.\r\n\r\nFurthermore, this conversion strictly follows the theory of Boolean algebra. \r\n\r\nI want to thank you all for your kindness and your participation", "created_at": "2017-02-01 19:18:04", "user": 48430, "id": 276752822}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276754518", "text": "@mikegee : Ruby is full of stuff that merely improves on readability. I love that about the language. I'd rather read .to_i after a boolean variable than anything else. It's opiniated. I confess ", "created_at": "2017-02-01 19:23:57", "user": 48430, "id": 276754518}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276759585", "text": "@tracyloisel \r\n\r\n> Ruby is full of stuff that merely improves on readability\r\n\r\nSyntactic sugar in Ruby such as `unless` and `size` + `length`, are fully application-agnostic, they don't assume anything about your usage: `unless` in one script can only have the same meaning in any other script. `size` on an Array can only have the same meaning as `size` and `length` on another Array. If you find this is not true, then you're not dealing with an Array and you should subclass/wrap it.\r\n\r\nThe same thing about application-agnosticism cannot be said of some global mapping of core constants to arbitrary values. This mapping only has its place as a library at best. Like a boolean algebra library.", "created_at": "2017-02-01 19:41:19", "user": 2480, "id": 276759585}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276767322", "text": "Gosh, the PR was missing rb_define_method instructions... Does anyone here really read the files changed ???? tsss", "created_at": "2017-02-01 20:09:02", "user": 48430, "id": 276767322}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/276770105", "text": "@tracyloisel please note @mikegee said:\r\n\r\n> https://bugs.ruby-lang.org/projects/ruby/wiki/HowToContribute says:\r\n>\r\n>> Pull request to https://github.com/ruby/ruby is acceptable for tiny fixes. But pull requests which need discussions will be simply ignored.\r\n\r\nSo no, we don't check.", "created_at": "2017-02-01 20:19:40", "user": 9831, "id": 276770105}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/281794109", "text": ">  It's opiniated. I confess\r\n\r\nI do not think that the opinion or being opinioated is the problem.\r\n\r\nUltimately any proposals have to convince matz primarily and the\r\ndiscussions happen on https://bugs.ruby-lang.org/projects/ruby-trunk \r\nalthough I also understand github discussion, they are very convenient.\r\n\r\nTo the topic at hand, I think that .to_i on true or false is a bit strange\r\nlargely because Ruby follows its own internal philosophy rather than\r\nC customs, e. g. \"0 being false and all else being true\" or actually\r\nthe reverse ... see, I can't even remember it, \"true\" and \"false\" are\r\nso much simpler than numbers. I always try to use 42, then I win\r\nif I return that number right? And, by the way, I can understand the\r\nproposal as well to some extent. I once also wanted something\r\nthat turns \"true\" into a real true value and \"false\" into a real false\r\nvalue, and my idea was to add a .bool or .to_bool method to \r\nruby ... :)\r\n\r\nIn LPC, a language that is largely C but used for some oldschool\r\nMUDs, they follow method invocation styles where, if a method\r\ndoes not exist, it does not crash the program or end it, it just\r\nassumes that the result will be wrong. Like:\r\n\r\n  object tp; tp = this_player();\r\n  sword->move(tp);\r\n\r\nOr something like that; and if the method move() does not exist,\r\nthings just continue but of course without the sword being relocated\r\nto the player object. There are pros and cons with that approach.\r\n(I mention it specifically because I once wanted to write a MUD in\r\nruby. I am still not even sure about which semantics to use... so \r\nI guess I may write two different engines where the behaviour\r\ncan be LPC-specific, or also ruby-specific).\r\n\r\nIn general ruby being so dynamic, one can just modify all the\r\nbehaviour as you want to. But I understand why you want to\r\nhave certain behaviour in the main language. :)\r\n\r\nWhile I personally am mildly against the proposal, it's nothing\r\nthat has me fret about it. But I think there are many somewhat\r\nsimilar suggestions here and there; it would be nice if there\r\ncould be an additional \"evil\" branch of ruby that may be as\r\nopinionated, where people can just pull in crazy stuff that \r\nmodifies how ruby behaves. Like in the above example,\r\nsomething like:\r\n\r\n  require 'bool_on_steroids'\r\n\r\nAnd similar requires that are available by default. :D\r\n\r\nThen people could specifically enable things like the\r\nabove, just with one extra require note.\r\n\r\n(Or if you want to denote that it is evil, you could have\r\nthe require be:\r\n\r\nrequire 'evil/bool_on_steroids'\r\n\r\nand group similar behaviour all into the evil namespace.\r\nThere used to be evil.rb, it was cool! Run-time change\r\nof classes to shapechange into other classes, I liked\r\nthe idea. Or to have a generic Button class, that, depending\r\non the GUI toolkit at hand, would be a Tk Button or a GTK\r\nButton or a QT button - you get the idea. Sorry for the \r\ndigression, I was just having too many ideas!)", "created_at": "2017-02-22 20:33:03", "user": 13723, "id": 281794109}], "assignees": [], "state": "open", "is-pull-request": true}, "303810042": {"text": "A new exception is raised if an URI::HTTP is received and that object doesn't\r\nhave a hostname property.\r\nComplementary to #1278 fix.", "labels": [], "number": 1835, "updated_at": "2018-03-09 11:25:52", "user": 1037088, "closed_at": null, "id": 303810042, "title": "Adding missing test for Net::HTTPGenericRequest initializer", "url": "https://api.github.com/repos/ruby/ruby/issues/1835", "created_at": "2018-03-09 11:25:52", "comments": [], "assignees": [], "state": "open", "is-pull-request": true}, "258368509": {"text": "This feature is required for cases like below:\r\n\r\n```ruby\r\n    queue = Queue.new\r\n\r\n    10.times do\r\n      Thread.new do\r\n        queue << Task.new(at: Time.now + 30)\r\n      end\r\n    end\r\n\r\n    Thread.new do # executor\r\n      while true\r\n        if queue.peek.to_be_fired?(Time.now)\r\n          task = queue.pop\r\n          # processing...\r\n        end\r\n        sleep INTERVAL\r\n      end\r\n    end\r\n```\r\n\r\nI have many use cases to enqueue tasks, which have conditions to be fetched or not. `Queue#peek` provides possibility to handle such requirement.", "labels": [], "number": 1698, "updated_at": "2018-02-23 03:07:38", "user": 230654, "closed_at": null, "id": 258368509, "title": "Add Queue#peek to fetch the head object in queue, without removing it.", "url": "https://api.github.com/repos/ruby/ruby/issues/1698", "created_at": "2017-09-18 04:32:47", "comments": [{"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/330145484", "text": "What if another thread `pop`s the `peek`\u2019d object and the condition is invalid? I think this is only safe for a single consumer so the documentation should have a note", "created_at": "2017-09-18 07:25:04", "user": 9831, "id": 330145484}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/330402857", "text": "@drbrain Correct - it's just for a single consumer.\r\n\r\nBut right now, I have another idea to get a solution for my problem by adding block argument to `Queue#pop`, instead of adding `Queue#peek`:\r\n\r\n```ruby\r\nThread.new do # executor\r\n  while true\r\n    if task = queue.pop{|task| task.to_be_fired?(Time.now) } # block is evaluated in mutex lock\r\n      # processing...\r\n    end\r\n    sleep INTERVAL\r\n  end\r\nend\r\n```\r\n\r\nThis idea can be applied for the case of multiple consumers.\r\nBut this fix requires to add mutex synchronization everywhere in code of `Queue`... Hmm.", "created_at": "2017-09-19 01:38:56", "user": 230654, "id": 330402857}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/332087506", "text": "The approach to accept block (to pop items) requires too large patch (to rewrite almost entire `Queue`), so it looks unacceptable.\r\nI pushed another commit on this pull-request to add thread unsafe.\r\n\r\nWhat do you think about it?", "created_at": "2017-09-26 05:06:13", "user": 230654, "id": 332087506}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/332124514", "text": "IMO that makes it sound *too* unsafe... by itself, it's no more \"unsafe\" than something like `q.pop unless q.empty?`\r\n\r\nThe above example is indeed unsafe for multiple consumers, but that's not being included in the documentation. (And could be fixed by the caller adding a separate consumer-only mutex around the peek-check-pop.)", "created_at": "2017-09-26 08:24:34", "user": 1034, "id": 332124514}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/332140044", "text": "Isn't the non-block version `Queue.pop(true)` enough for this?\r\nThen you immediately get an exception if the queue was empty, or its pops an element if there was one available.", "created_at": "2017-09-26 09:24:05", "user": 168854, "id": 332140044}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/332140442", "text": "We could also have a blocking version of `Queue#pop` with a timeout, that's easy to implement and safer.", "created_at": "2017-09-26 09:25:42", "user": 168854, "id": 332140442}, {"reactions": {}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/332158784", "text": "@eregon that doesn't put the item back onto the head of the queue if the condition is false\r\n\r\n(a timeout on `Queue#pop` would certainly be nice -- but it seems unrelated to this use case)", "created_at": "2017-09-26 10:40:53", "user": 1034, "id": 332158784}, {"reactions": {"+1": [3461316]}, "url": "https://api.github.com/repos/ruby/ruby/issues/comments/332173121", "text": "Right, I missed that part.\r\n\r\nIn such a case which only works with one consumer, maybe the simplest is just to use a custom class using an Array and a Mutex, which synchronizes push and pop:\r\n```ruby\r\ndef push(e)\r\n  @mutex.synchronize do\r\n    @array.push(e)\r\n  end\r\nend\r\n\r\ndef pop\r\n  @mutex.synchronize do\r\n    unless @array.empty?\r\n      if yield @array.first\r\n        @array.shift\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\nThat seems better than adding a method to Queue that would only make sense when there is only one consumer.", "created_at": "2017-09-26 11:46:01", "user": 168854, "id": 332173121}], "assignees": [], "state": "open", "is-pull-request": true}}